\subject[if] ConditionalsConditionals are an indispensible tool for powerful macros.\term conditionals\par\TeX\ has a large repertoire of conditionals for queryingsuch things as category codes or processing modes.This chapter gives an inventory of the various conditionals,and it treats the evaluation ofconditionals in detail.\invent\item if       Test equality of character codes. \item ifcat       Test equality of category codes. \item ifx       Test equality of macro expansion, or equality of character code and      category code.\item ifcase       Enumerated case statement.\item ifnum       Test relations between numbers.\item ifodd       Test whether a number is odd.\item ifhmode       Test whether the current mode is (possibly restricted) horizontal mode.\item ifvmode       Test whether the current mode is (possibly internal) vertical mode.\item ifmmode      Test whether the current mode is (possibly display) math mode.\item ifinner       Test whether the current mode is an internal mode.\item ifdim       Compare two dimensions. \item ifvoid       Test whether a box register is empty.\item ifhbox       Test whether a box register contains a horizontal box.\item ifvbox       Test whether a box register contains a vertical box. \item ifeof       Test for end of input stream or non-existence of file.\item iftrue       A test that is always true.\item iffalse       A test that is always false.\item fi       Closing delimiter for all conditionals.\item else       Select \gr{false text} of a conditional       or default case of \cs{ifcase}.\item or       Separator for entries of an \cs{ifcase}.\item newif      Create a new test.\inventstop\point The shape of conditionalsConditionals in \TeX\ have one of the following two forms\csterm else\par\csterm fi\par\disp\cs{if...}\gr{test tokens}\gr{true text}\cs{fi}\nl     \cs{if...}\gr{test tokens}\gr{true text}\cs{else}%     \gr{false text}\cs{fi}\dispstopwhere the \gr{test tokens} are zero or more tokens, depending onthe particular conditional; the \gr{true text} is a series of tokensto be processed if the test turns out true, and the \gr{false text}is a series of tokens to be processed if the test turns out false.Both the \gr{true text} and the \gr{false text} can be empty.The exact process of how \TeX\ expands conditionals is treatedbelow.\point Character and control sequence testsThree tests exist for testing character tokens andcontrol sequence tokens.\spoint \cs{if}Equality of character codes can be tested by\csterm if\par\Disp\cs{if}\gr{token$_1$}\gr{token$_2$}\DispstopIn order to allow the tokens to be control sequences,\TeX\ assigns character code~256 to control sequences,the lowest positive number that is not the character code of acharacter token (remember that the legal character codesare~0--255).Thus all control sequences are equal as far as \cs{if} isconcerned, and they are unequal to all character tokens.As an example, this fact can be used to define\howto Test whether a token is a control sequence\par\Ver>\def\ifIsControlSequence#1{\if\noexpand#1\relax}<Revwhich tests whether a token is a control sequence tokeninstead of a character token (its result is unpredictableif the argument is a \ver>{...}> group).After \cs{if} \TeX\ will expand until two unexpandabletokens are obtained, so it is necessary to prefixexpandable control sequences and active characterswith \cs{noexpand} when testing them with~\cs{if}.\examples After\Ver>\catcode`\b=13 \catcode`\c=13 \def b{a} \def c{a} \let\d=a<Revwe find that\tdisp\ver-\if bc- is true, because both \n b and \n c expand to \n a,\nl\ver-\if\noexpand b\noexpand c- is false, and\nl\ver-\if b\d- is true because \n{b} expands to the character~\n{a},   and \cs{d} is an implicit character token~\n{a}.\>\>\spoint \cs{ifcat}The \cs{if} test ignores category codes; these can be tested\csterm ifcat\parby \Disp\cs{ifcat}\gr{token$_1$}\gr{token$_2$}\DispstopThis test is a lot like \cs{if}: \TeX\ expands after ituntil unexpandable tokens remain. For this testcontrol sequencesare considered to have category code~16(ordinarily, category codes are in the range~0--15), which makes themall equal to each other, and different from all charactertokens.\spoint \cs{ifx}Equality of tokens is tested in a stronger sense than\csterm ifx\parthe above by \Disp\cs{ifx}\gr{token$_1$}\gr{token$_2$}\Dispstop\itemlist\item Character tokens are equal for \cs{ifx} ifthey have the same character code and category code.    \item Control sequence tokens are equal if they represent thesame \TeX\ primitive, or have been similarly defined by\cs{font}, \cs{countdef}, or some such. For example,\Ver>\let\boxhor=\hbox \ifx\boxhor\hbox %is true\font\a=cmr10 \font\b=cmr10 \ifx\a\b %is true<Rev\item Control sequences are also equal if they aremacros with the same parameter text and replacement text,and the same status with respect to \cs{outer} and~\cs{long}.For example,\Ver>\def\a{z} \def\b{z} \def\c1{z} \def\d{\a}\ifx\a\b %is true\ifx\a\c %is false\ifx\a\d %is false<Rev\itemliststopTokens following this test are not expanded.By way of example of the use of \cs{ifx} consider string testing.A simple implementation of string testing in \TeX\ is as follows:\Ver>\def\ifEqString#1#2{\def\testa{#1}\def\testb{#2}%    \ifx\testa\testb}<RevThe two strings are used as the replacement text of two macros,and equality of these macros is tested.This is about as efficient as string testing can get:\TeX\ will traverse the definition texts of themacros \cs{testa} and \cs{testb}, which has precisely theright effect.As another example, one can test whether a control sequence is definedby\howto Test whether a control sequence is (un)defined\par\Ver>\def\ifUnDefinedCs#1{\expandafter    \ifx\csname#1\endcsname\relax}\ifUnDefinedCs{parindent} %is not true\ifUnDefinedCs{undefined} %is (one hopes) true<RevThis uses the fact that a \ver>\csname...\endcsname> commandis equivalent to \cs{relax} if the control sequencehas not been defined before. Unfortunately, this test alsoturns out true if a control sequence has been \cs{let} to\cs{relax}.\point Mode testsIn order to determine in which of the six modes (see Chapter~\ref[hvmode]) \TeX\ \csterm ifhmode\par\csterm ifvmode\par\csterm ifmmode\par\csterm ifinner\paris currently operating, the tests \cs{ifhmode}, \cs{ifvmode}, \cs{ifmmode}, and~\cs{ifinner}are available.\itemlist\item\cs{ifhmode} is true if \TeX\ is in horizontal modeor restricted horizontal mode.\item\cs{ifvmode} is true if \TeX\ is in vertical mode orinternal vertical mode.\item\cs{ifmmode} is true if \TeX\ is in math mode or displaymath mode.\itemliststopThe \cs{ifinner} test is true if \TeX\ is in any of the threeinternal modes: restricted horizontal mode, internal verticalmode, and non-display math mode.\point Numerical testsNumerical relations between \gr{number}s can be tested\csterm ifnum\parwith \disp\cs{ifnum}\gr{number$_1$}\gr{relation}%\gr{number$_2$}\dispstopwhere the relation is a character \n{<}, \n{=}, or~\n{>},of category~12.Quantities such as glue can be used as a number herethrough the conversion to scaled points, and \TeX\will expand in order to arrive at the two \gr{number}s.Testing for odd or even numbers can be done with \cs{ifodd}:\csterm ifodd\parthe test\disp\cs{ifodd}\gr{number}\dispstopis true if the \gr{number} is odd.\point Other tests\spoint Dimension testingRelations between \gr{dimen} values (Chapter~\ref[glue])\csterm ifdim\parcan be tested with\cs{ifdim} using the same three relations as in \cs{ifnum}.\spoint Box testsContents of box registers (Chapter~\ref[boxes]) can be tested with\csterm ifhbox\par\csterm ifvbox\par\csterm ifvoid\par\disp\cs{ifvoid}\gr{8-bit number}\>which is true if the register contains no box,\disp\cs{ifhbox}\gr{8-bit number}\>which is true if the register contains a horizontal box, and\disp\cs{ifvbox}\gr{8-bit number}\>which is true if the register contains a vertical box.\spoint I{/}O testsThe status of input streams (Chapter~\ref[io]) can be tested with\csterm ifeof\parthe end-of-file test\cs{ifeof}\gr{number}, which is only falseif the number is in the range 0--15, and the correspondingstream is open and not fully read. In particular, this testis true if the file name connectedto this stream (through \cs{openin})does not correspond to an existing file.See the example on page~\pgref[ex:eof].\spoint Case statementThe \TeX\ case statement is called \cs{ifcase};\csterm ifcase\par\csterm or\parits syntax is\disp\cs{ifcase}\gr{number}\gr{case$_0$}\cs{or}%\n{...}\cs{or}\gr{case$_n$}\cs{else}\gr{other cases}\cs{fi}\dispstop where for $n$ cases there are $n-1$ \cs{or}control sequences. Each of the \gr{case$_i$}parts can be empty,and the \cs{else}\gr{other cases} part is optional.\spoint Special testsThe tests \cs{iftrue} and \cs{iffalse} are always\csterm iftrue\par\csterm iffalse\partrue and false respectively.They are mainly useful as tools in macros.For instance, the sequences \Ver>\iftrue{\else}\fi<Revand \Ver>\iffalse{\else}\fi<Rev yield a left and rightbrace respectively, but they have balanced braces, so theycan be used inside a macro replacement text.The \cs{newif} macro, treated below,provides another use of \cs{iftrue} and \cs{iffalse}.On page 260 of \TeXbook\ these control sequencesare also used in an interesting manner.\point[newif:def] The \cs{\newif} macroThe plain format defines an (outer) macro \cs{newif} by\csterm newif\parwhich the user can define new conditionals.If the user defines \Ver>\newif\iffoo<Rev\TeX\ defines three new control sequences,\cs{footrue} and \cs{foofalse} with which the user can setthe condition, and \cs{iffoo} which tests the `foo' condition.The macro call \ver-\newif\iffoo- expands to\Ver>\def\footrue{\let\iffoo=\iftrue} \def\foofalse{\let\iffoo=\iffalse}\foofalse<RevThe actual definition, especially the part that ensures thatthe \cs{iffoo} indeed starts with \cs{if}, is a pretty hack.An explanation follows here.This uses concepts from Chapters~\ref[macro]and~\ref[expand].The macro \cs{newif} starts as follows:\Ver>\outer\def\newif#1{\count@\escapechar \escapechar\m@ne<RevThis saves the current escape character in \cs{count@}, andsets the value of \cs{escapechar} to~\n{-1}.The latter action has theeffect that no escape character is used in the outputof \cs{string}\gr{control sequence}.An auxiliary macro \ver>\if@> is defined by\Ver>{\uccode`1=`i \uccode`2=`f \uppercase{\gdef\if@12{}}}<RevSince the uppercase command changes only character codes, andnot category codes, the macro \cs{if@} now hasto be followed by the characters \n{if} of category~12.Ordinarily, these characters have category code~11.In effect thismacro then eats these two characters, and \TeX\ complains ifthey are not present.Next there is a macro \ver>\@if> defined by\Ver>\def\@if#1#2{\csname\expandafter\if@\string#1#2\endcsname}<Revwhich will be called like \ver>\@if\iffoo{true}> and\ver>\@if\iffoo{false}>. Let us examine the call \ver>\@if\iffoo{true}>.\itemlist\item The \cs{expandafter} reaches over the \ver>\if@>to expand \cs{string} first. The part \ver>\string\iffoo>expands to \n{iffoo} because the escape character is not printed,and all characters have category~12.\item The \ver>\if@> eats the first two characters\n i$_{12}$\n f$_{12}$ of this.\item As a result, the final expansion of \ver>\@if\iffoo{true}>is then \Ver>\csname footrue\endcsname<Rev\itemliststopNow we can treat the relevant parts of \cs{newif} itself:\Ver>\expandafter\expandafter\expandafter   \edef\@if#1{true}{\let\noexpand#1=\noexpand\iftrue}%<RevThe three \cs{expandafter} commands may look intimidating, so let ustake one step at a time.\itemlist\item One \cs{expandafter} is necessary to reach over the \cs{edef},such that \ver>\@if> will expand:\Ver>\expandafter\edef\@if\iffoo{true}<Rev gives\Ver>\edef\csname footrue\endcsname<Rev\item Then another \cs{expandafter} is necessary to activate\alttthe \cs{csname}:\Ver>\expandafter \expandafter \expandafter \edef \@if ...%   new          old          new<Rev\item This makes the final expansion \Ver>\edef\footrue{\let\noexpand\iffoo=\noexpand\iftrue}<Rev\itemliststopAfter this follows a similar statement for the \n{false} case:\Ver>   \expandafter\expandafter\expandafter   \edef\@if#1{false}{\let\noexpand#1=\noexpand\iffalse}%<RevThe conditional starts out false, and the escape characterhas to be reset:\Ver>  \@if#1{false}\escapechar\count@} <Rev\point Evaluation of conditionals\TeX's conditionals behave differently from those\term conditionals, evaluation\parin ordinary programming languages. In many instancesone may not notice the difference, but in certain contextsit is important to know precisely what happens.When \TeX\ evaluates a conditional, it first determineswhat is to be tested. This in itself may involve someexpansion; as we saw in the previous chapter, only after an \cs{ifx} testdoes \TeX\  not expand. After all other tests \TeX\ willexpand tokens until the extent of the test and the tokensto be tested have been determined. On the basis of the outcomeof this test the \gr{true text} and the \gr{false text}are either expanded or skipped.For the processing of the parts of the conditionallet us consider some cases separately.\itemlist\item \ver>\if... ... \fi> and the result of the test is false. After the test \TeX\ will start skipping material without expansion, without counting braces, but balancing nested conditionals, until a \cs{fi} token is encountered. If the \cs{fi} is not found an error message results at the end of the file: \disp\tt Incomplete \cs{if...}; all text was ignored after line \n{...} \dispstop where the line number indicated is that of the line where \TeX\ started skipping, that is, where the conditional occurred.\item \ver>\if... \else ... \fi> and the result of the test is false. Any material in between the condition and the \cs{else} is skipped without expansion, without counting braces, but balancing nested conditionals. The \cs{fi} token can be the result of expansion; if it never turns up \TeX\ will give a diagnostic message \disp\tt \cs{end} occurred when \cs{if...} on line \n{...}      was incomplete\dispstop This sort of error is not visible in the output. This point plus the previous may jointly be described as follows: after a false condition \TeX\ skips until an \cs{else} or \cs{fi} is found; any material in between \cs{else} and \cs{fi} is processed. \item \ver>\if... ... \fi> and the result of the test is true. \TeX\ will start processing the material following the condition. As above, the \cs{fi} token may be inserted by expansion of a macro. \item \ver>\if... \else ... \fi> and the result of the test is true. Any material following the condition is processed until the \cs{else} is found; then \TeX\ skips everything until the matching \cs{fi} is found.  This point plus the previous may be described as follows: after a true test \TeX\ starts processing material until an \cs{else} or \cs{fi} is found; if an \cs{else} is found \TeX\ skips until it finds the matching \cs{fi}.\itemliststop\point Assorted remarks\spoint The test gobbles up tokensA common mistake is to write the following:\Ver>\ifnum\x>0\someaction \else\anotheraction \fi<Revwhich has the effect that the \ver.\someaction. is expanded,regardless of whether the test succeeds or not. The reason for this is that \TeX\ evaluates the input stream untilit is certain that it has found the arguments to be tested.In this case it is perfectly possible for the \ver.\someaction.to yield a digit, so it is expanded. The remedy is to insert\altta space or a \cs{relax} control sequenceafter the last digit of the number to be tested.\spoint The test wants to gobble up the \cs{else} or \cs{fi}The same mechanism that underlies the phenomenon in the previouspoint can lead to even more surprising effects if \TeX\bumps into an \ver.\else., \ver.\or., or \ver.\fi. while still busy determining the extent of the test itself.Recall that \ver.\pageno. is a synomym for \ver.\count0., andconsider the following examples:\Ver>\newcount\nct \nct=1\ifodd\pageno\else 2\fi 1<Revand\Ver>\newcount\nct \nct=1\ifodd\count0\else 2\fi 1<RevThe first example will assign either 11 or~121 to \cs{nct}, but the second one will assign 1 or~121. The explanation is thatin cases like the second, where\alttan \ver.\else. is encountered while thetest still has not been delimited, a \ver.\relax. is inserted.In the case that \ver.\count0. is odd the result will thus be \ver.\relax.,and the example will yield \Ver>\nct=1\relax2<Revwhich will assign~1 to \cs{nct}, and print~2.\spoint[after:cond] Macros and conditionals; the use of \cs{expandafter}Consider the following example:\Ver>\def\bold#1{{\bf #1}} \def\slant#1{{\sl #1}}\ifnum1>0 \bold \else \slant \fi {some text} ...<RevThis will make not only `some text', but {\sl all\/} subsequent text bold.Also, at the end of the job there will be a notice that`end occurred inside a group at level~1'.Switching on \cs{tracingmacros} reveals that the argumentof \ver.\bold. was \ver.\else..This means that, after expansion of \ver.\bold., the input stream looked like\Ver>\ifnum1>0 {\bf \else }\fi {some text} rest of the text <Revso the closing brace was skipped as part of the \gram{false text}.Effectively, then, the resulting stream is\Ver>{\bf {some text} rest of the text<Revwhich is unbalanced.One solution to this sort of problem would be to write\Ver>\ifnum1>0 \let\next=\bold \else \let\next=\slant \fi \next<Revbut  a solution using \cs{expandafter} is also possible:\Ver>\ifnum1>0 \expandafter \bold \else \expandafter \slant \fi<RevThis works, because the \cs{expandafter} commands let \TeX\ determinethe boundaries of the \gram{true text} and the \gram{false text}.In fact, the second solution may be preferred over the first,since conditionals are handled by the expansion processor,and the \cs{let} statements are tackled only by the executionprocessor; that is, they are not expandable.Thus the second solution will (and the first will not)work, for instance,inside an~\cs{edef}.Another example with \cs{expandafter} is the sequence\Ver>\def\get#1\get{ ... }\expandafter \get \ifodd1 \ifodd3 5\fi \fi \get<RevThis gives\Ver>#1<- \ifodd3 5\fi \fi<Rev and\Ver>\expandafter \get \ifodd2 \ifodd3 5\fi\fi \get<Revgives\Ver>#1<-<RevThis illustrates again that the result of evaluating a conditional is not the final expansion, but the startof the expansion of the \gr{true text} or \gr{false text},depending on the outcome of the test.A detail should be noted: with \cs{expandafter}it is possible that the \ver.\else. is encounteredbefore the \gram{true text} has been expanded completely.This raises the question as to the exact timing of expansionand skipping.In the example\Ver>\def\hello{\message{Hello!}}\ifnum1>0 \expandafter \hello \else \message{goodbye} \bye<Revthe error message caused by the missing \ver.\fi. is givenwithout \ver.\hello. ever having been expanded.The conclusion must be that the \gram{false text} isskipped as soon as it has been located, even if this is at a timewhen the \gram{true text} has not been expanded completely.\spoint Incorrect matching\TeX's matching of \ver.\if., \ver.\else., and \ver.\fi.is easily upset. For instance, \TeXbook\ warns you thatyou should not say \Ver> \let\ifabc=\iftrue<Rev inside a conditional, because if this text is skipped \TeX\ seesat least one \ver.\if. to be matched. The reason for this is that when \TeX\ is skippingit recognizes all \cs{if...}, \cs{or}, \cs{else}, and \cs{fi}tokens, and everything that has been declared a synonym ofsuch a token by \cs{let}. In \ver>\let\ifabc=\iftrue>\TeX\ will therefore at least see the \cs{iftrue} asthe opening of a conditional, and, if the current meaningof \cs{ifabc} was for instance \cs{iffalse}, it will alsobe considered as the opening of a conditional statement.As another example, if\Ver> \csname if\sometest\endcsname \someaction \fi<Revis skipped as part of conditional text,the \ver.\fi. will unintentionally close theouter conditional.It does not help to enclose such potentially dangerousconstructs inside a group, because grouping is independent ofconditional structure. Burying such commands inside macros isthe safest approach.Sometimes another solution is possible, however.The \cs{loop} macro of plain \TeX\ (see page~\pgref[loop:ex])is used as \Ver>\loop ... \if ... \repeat<Revwhere the \cs{repeat} is not an actually executablecommand, but is merely a delimiter:\Ver>\def\loop#1\repeat{ ... }<RevTherefore,by declaring \Ver>\let\repeat\fi<Revthe \cs{repeat} balances the \cs{if...} that terminatesthe loop, and it becomes possible to have loops inskipped conditional text.\spoint Conditionals and groupingIt has already been mentioned above that group nesting in \TeX\is independent of conditional nesting.The reason for this is that conditionals are handled by theexpansion part of \TeX; in that stage braces are justunexpandable tokens that require no special treatment.Grouping is only performed in the later stage of executionprocessing.An example of this independence is now given.One may write a macro that yields part ofa conditional:\Ver>\def\elsepart{\else \dosomething \fi}<RevThe other way around, the following macrosyield a left brace and a right brace respectively:\Ver>\def\leftbrace{\iftrue{\else}\fi}\def\rightbrace{\iffalse{\else}\fi}<RevNote that braces in these definitions are properly nested.\spoint A trickIn some contexts it may be hard to get rid of\cs{else} or \cs{fi} tokens in a propermanner. The above approach with \cs{expandafter}works only if there is a limited number of tokens involved.In other cases the following trick may provide a way out:\Ver>\def\hop#1\fi{\fi #1}<Rev Using this as\disp\ver>\if... \hop >\gr{lots of tokens}\ver>\fi>\dispstopwill place the tokens outside the conditional.This is for instance used in~\cite[E2].As a further example of this sort of trick,consider the problem (suggested to me and solved byAlan Jeffrey) of implementing a conditional \ver-\ifLessThan#1#2#3#4-such that the arguments corresponding to \ver-#3- or\ver-#4- result, depending on whether \ver-#1- isless than \ver-#2- or not. The problem here is how to get rid of the \cs{else} and the~\cs{fi}.The \ldash or at least, one \rdash solution is to scoop them upas delimiters for macros:\Ver>\def\ifLessThan#1#2{\ifnum#1<#2\relax\taketrue \else \takefalse \fi}\def\takefalse\fi#1#2{\fi#2}\def\taketrue\else\takefalse\fi#1#2{\fi#1}<RevNote that \cs{ifLessThan} has only two parameters(the things to be tested); however, itsresult is a macro thatchooses between the next two arguments.\spoint More examples of expansion in conditionalsAbove, the macro \cs{ifEqString} was given\altthat compares two strings:\howto Compare two strings\par\Ver>\def\ifEqString#1#2%   {\def\csa{#1}\def\csb{#2}\ifx\csa\csb }<RevHowever, this macro relies on \cs{def},  which is not anexpandable command. If we need a string tester that willwork, for instance, inside an  \cs{edef}, we need somemore ingenuity (this solution was taken from~\cite[E2]).The basic principle of this solution is to compare the stringsone character at a time. Macro delimiting by \cs{fi} is used;this was explained above.First of all, the \cs{ifEqString} call is replaced by asequence \ver>\ifAllChars ...\Are ...\TheSame>, and bothstrings are delimited by a dollar sign, which is not supposedto appear in the strings themselves.\Ver>\def\ifEqString    #1#2{\ifAllChars#1$\Are#2$\TheSame}<RevThe test for equality of characters first determineswhether either string has ended. If both have ended, the originalstrings were equal; if only one has ended, they were of unequallength, hence unequal. If neither string has ended, we testwhether the first characters are equal, and if so, we make a recursivecall to test the remainder of the string.\Ver>\def\ifAllChars#1#2\Are#3#4\TheSame   {\if#1$\if#3$\say{true}%          \else \say{false}\fi    \else \if#1#3\ifRest#2\TheSame#4\else                 \say{false}\fi\fi}\def\ifRest#1\TheSame#2\else#3\fi\fi   {\fi\fi \ifAllChars#1\Are#2\TheSame}<RevThe \cs{say} macro is supposed to  give \cs{iftrue} for\ver>\say{true}> and \cs{iffalse} for \ver>\say{false}>.Observing that all  calls to this macro occur two conditionals deep,we use the `hop' trick explained above as follows.\Ver>\def\say#1#2\fi\fi   {\fi\fi\csname if#1\endcsname}<RevSimilar to the above example, let us write a macrothat will test lexicographic (`dictionary') precedenceof two strings:\howto Compare two strings lexicographically\par\Ver>\let\ex=\expandafter\def\ifbefore    #1#2{\ifallchars#1$\are#2$\before}\def\ifallchars#1#2\are#3#4\before   {\if#1$\say{true\ex}\else     \if#3$\say{false\ex\ex\ex}\else      \ifnum`#1>`#3 \say{false%         \ex\ex\ex\ex\ex\ex\ex}\else       \ifnum`#1<`#3 \say{true%         \ex\ex\ex\ex\ex\ex\ex         \ex\ex\ex\ex\ex\ex\ex\ex}\else       \ifrest#2\before#4\fi\fi\fi\fi}\def\ifrest#1\before#2\fi\fi\fi\fi   {\fi\fi\fi\fi    \ifallchars#1\are#2\before}\def\say#1{\csname if#1\endcsname}<RevIn this macro a slightlydifferent implementation of \cs{say} is used.Simplified, a call to \cs{ifbefore} will eventually lead to a situationthat looks (in the `true' case) like\Ver>\ifbefore{...}{...}       \if... %% some comparison that turns out true          \csname iftrue\expandafter\endcsname       \else .... \fi   ... %% commands for the `before' case\else   ... %% commands for the `not-before' case\fi<RevWhen the comparison has turned out true, \TeX\ will start processingthe \gr{true text}, and make a mental note to remove any\ver>\else ... \fi> part once an \cs{else} token is seen.Thus, the sequence\Ver>\csname iftrue\expandafter\endcsname \else ... \fi<Revis replaced by \Ver> \csname iftrue\endcsname<Revas the \cs{else} is seen while \TeX\ is still processing\ver>\csname...\endcsname>.Calls to \cs{say} occur inside nested conditionals, sothe number of \cs{expandafter} commands necessary may be \altlarger than~1: for level two it is~3, for level threeit is~7, and for level~4 it is 15. Slightly more compactimplementations of this macro do exist.\endinput