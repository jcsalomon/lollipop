\subject[macro]  MacrosMacros are \TeX's abbreviation mechanism for sequences of commandsthat are needed more than once,somewhat like procedures in ordinary programming languages.\TeX's parameter mechanism, however, is quite unusual.This chapter explains how \TeX\ macros work. It alsotreats the commands \cs{let} and~\cs{futurelet}.\invent\item def       Start a macro definition.\item gdef       Synonym for \ver-\global\def-.\item edef       Start a macro definition;       the replacement text is expanded at definition time.      This command is treated also in the next chapter.\item xdef       Synonym for \ver-\global\edef-.\item csname       Start forming the name of a control sequence.\item endcsname       Stop forming the name of a control sequence.\item global       Make the next definition, arithmetic statement,      or assignment global.\item outer       Prefix indicating that the macro being defined       can be used on the `outer' level only.\item long       Prefix indicating that the arguments of the macro being defined      may contain \cs{par} tokens.\item let       Define a control sequence to be equivalent to the next token.\item futurelet       Define a control sequence to be equivalent to      the token after the next token.\inventstop\point IntroductionA macro is basically a sequence of tokens that has\term macros\parbeen abbreviated into a control sequence.Statements starting with (among others) \cs{def}are called {\italic macro definitions}\alt, andwriting \Ver>\def\abc{\de f\g}<Rev defines the macro \cs{abc},with the {\italic replacement text\/} \ver>\de f\g>.Macros can be used in this way to abbreviatepieces of text or sequences of commandsthat have to be given more than once.Any time that \TeX's expansion processorencounters the control sequence \cs{abc},it replaces it by the replacement text.If a macro should be sensitive to the contextwhere it is used, it can be defined with parameters:\Ver>\def\PickTwo#1#2{(#1,#2)}<Revtakes two arguments and reproduces them in parentheses.The call \cs{PickTwo 12} gives `(1,2)'.The activity of substituting the replacement textfor a macro is called {\italic macro expansion}.\point Layout of a macro definitionA macro definition consists of, in sequence,\term macro definition\par\enumerate \item any number of \cs{global},\cs{long}, and \cs{outer} prefixes,\item a \gr{def} control sequence, or anythingthat has been \cs{let} to one,\item a control sequence or active character to be defined, \item possibly a \gr{parameter text} specifying among other thingshow many parameters the macro has, and\item a replacement text enclosed in explicit character tokenswith category codes 1 and~2, by default \ver-{- and~\ver-}-in plain \TeX.\>The `expanding' definitions \cs{edef} and \cs{xdef}are treated in Chapter~\ref[expand].\point PrefixesThere are three prefixes that alter the status of the\term macro prefixes\parmacro definition: \description\item \cs{global}If the definition occurs inside a  group, this prefixmakes the definition global\csterm global\par. This prefix can also be used for assignments other thanmacro definitions; in fact,for macro definitions abbreviations exist obviating theuse of \cs{global}:\disp\ver>\gdef\foo...>\quad is equivalent to\quad \ver>\global\def\foo...>\dispstop and\disp\ver>\xdef\foo...>\quad is equivalent to\quad \ver>\global\edef\foo...>\dispstopIf the parameter \cs{globaldefs}is positive, all assignments areimplicitly global;if \cs{globaldefs} is negative any \cs{global} prefixes areignored,and \cs{gdef} and \cs{xdef} make local definitions(see Chapter~\ref[group]).\item \cs{outer}The mechanism of `outer' macros is supposed to facilitate\term outer macros\par\csterm outer\parlocating (among other errors) unbalanced braces: an \cs{outer}macro is supposedto  appear only in non-embedded contexts.To be precise, it is not allowed to occur \itemlist\item in macro replacement texts (but it can appear in    for instance \cs{edef} after     \cs{noexpand}, and after \cs{meaning}),\item in parameter texts,\item in skipped conditional text,\item in alignment preambles, and\item in the \gram{balanced text} of a \cs{message}, \cs{write},et cetera. \itemliststopFor certain applications, however, it is inconvenientthat some of the plain macros  are outer, in particular macros such as \cs{newskip}. One remedy is toredefine them, without the `outer' option, whichis done for instance in \LaTeX, but  cleverer tricks are possible.\item \cs{long}Ordinarily, macro parameters are not supposed to contain\csterm long\par\cs{par} tokens. This restriction is useful (much more sothan the \cs{outer} definitions) in locatingforgotten closing braces. For example, \TeX\ will complain about a `runaway argument'\message{Example on}in the following sequence:\Ver>\def\a#1{ ... #1 ... }\a {This sentence should be in braces.And this is not supposed to be part of the argument<Rev\message{one page}The empty line generates a \cs{par}, which most of the timesmeans that a closing brace has been forgotten.If arguments to a particular macro should be allowedto contain \cs{par} tokens,  then the macro must be declaredto be \cs{long}. \descriptionstopThe \cs{ifx} test for equality of tokens (see Chapter~\ref[if]) takes prefixes intoaccount when testing whether two tokens have the same definition.\commentWith a little ingenuity it is possible for \cs{par} tokens to sneak into macro arguments anyway.Consider the example\Ver>\def\a#1\par!{ ... }\a bc\par ef\par!<RevHere the macro \cs{a} is not \cs{long}, but the argumentis \ver>bc\par ef>, which contains a \cs{par} token.However,this is of no importance in general.\endcomment\point The definition typeThere are four \gr{def} control sequences in \TeX:\csterm def\par\csterm gdef\par\csterm edef\par\csterm xdef\par\cs{def}, \cs{gdef}, \cs{edef}, and \cs{xdef}.The control sequence \alt\cs{gdef} is a synonym for \ver>\global\def> and\cs{xdef} is a synonym for \ver>\global\edef>.The `expanding definition' \cs{edef} is treated in Chapter~\ref[expand].The difference between the various types of macro definitionsis only relevant at the time of the definition.When a macro is called there is no way of telling howit was defined.\point[param:text] The parameter textBetween the control sequence or active character to be defined\term parameters\par\term arguments\parand the opening brace of the replacement text, a \gr{parametertext} can occur. This specifies whether the macro has parameters,how many, and how they are delimited. The \gr{parameter text} cannot containexplicit braces.A macro can have at most nine parameters. A~parameter is indicated by a parameter token,consisting of a macro parameter character(that is, a character of category code~6, in plain \TeX~\ver=#=) followed by a digit~\n1--\n9. For instance, \ver>#6>~denotes the sixth parameter of a macro.Parameter tokens cannot appear outside the contextof a macro definition.In the parameter text,parameters must be numbered consecutively, starting at~1.A~space after a parameter token is significant,both in the parameter text and the replacement text.Parameters can be delimited or undelimited. A~parameteris called undelimited if it is followed immediatelyby another parameter in the \gr{parameter text}or by the opening brace of the replacement text;it is called delimited if it is followed by any other token.The tokens (zero or more) that are substituted fora parameter when a macro is expanded (or `called')are calledthe `argument' corresponding to that parameter.\spoint Undelimited parametersWhen a macro with an undelimited parameter, for instance\term undelimited parameters\para macro \cs{foo} with one parameter\Ver>\def\foo#1{ ... #1 ...}<Revis expanded, \TeX\ scans ahead (without expanding)until a non-blank token is found.If this token is not an explicit \gr{left brace}, it is taken to be the argumentcorresponding to the parameter. Otherwise a \gr{balanced text}is absorbed by scanning until the matching explicit\gr{right brace} has been found.This balanced text thenconstitutes the argument.An example with three undelimited parameters follows: with\Ver>\def\foo#1#2#3{#1(#2)#3}<Revthe macro call \cs{foo123} gives `\hbox{1(2)3}';but \hbox{\ver-\foo 1 2 3-} also gives the same result.In the call\disp\cs{foo}\n{\char32 1\char32 2\char 32 3}\dispstopthe first space is skipped in the input processor of \TeX.The argument corresponding to the first parameter is thenthe~\n1. In order to find the second parameter \TeX\ thenskips all blanks, in this case exactly one. As secondparameter \TeX\ finds then the~\n2. Similarly the thirdparameter is~\n3.In order to pass several tokens as one undelimited argumentone can use braces. With the above definition of \cs{foo}the call \ver>\foo a{bc}d> gives `\hbox{a(bc)d}'.When the argument of a macro is a balanced text instead ofa single token, the delimiting braces are not inserted when the argument isinserted in the replacement text.For example:\Ver>\def\foo#1{\count0=1#1\relax}\foo{23}<Rev will expand to \ver>\count0=123\relax>,which assigns the value of 123 to the counter.On the other hand,  the statement \Ver>\count0=1{23}<Rev wouldassign~1 and print~23.\spoint Delimited parametersApart from enclosing it in braces there is another way\term delimited parameters\parto pass a sequence of tokens as a single argument to a macro,namely by using delimited parameters.Any non-parameter tokens in the \gr{parameter text} occurringafter a macro parameter (that is, after the parameter numberfollowing the parameter character)act as a delimiter for that parameter. This includes space tokens:a space after a parameter number is significant.Delimiting tokens can also occur between the controlsequence being defined and the first parameter token~\ver>#1>.Character tokens acting as delimiters in the parameter texthave both their character code andcategory code stored; the delimiting character tokens of theactual arguments have to match both.Category codes of such characters may include some thatcan normally only appear in special contexts; for instance, afterthe definition \Ver>\def\foo#1_#2^{...}<Rev the macro \cs{foo}can be used outside math mode.When looking for the argument corresponding toa delimited parameter, \TeX\ absorbs all tokens without expansion (butbalancing braces) until the (exact sequence of) delimiting tokens is encountered.The delimiting tokens are not part of the argument;they are removed from the input stream during the macro call.\spoint Examples with delimited argumentsAs a simple example, \Ver>\def\DoASentence#1#2.{{#1#2.}}<Revdefines a macro with an undelimited first parameter,and a second parameter delimited by a period.In the call\Ver>\DoASentence \bf This sentence is the argument.<Revthe arguments are:\Ver>#1<-\bf#2<-This sentence is the argument<RevNote that the closing period is not in the argument, but it hasbeen absorbed; it is no longer in the input stream.A~commonly used delimiter is \cs{par}:\Ver>\def\section#1. #2\par{\medskip\noindent {\bf#1. #2\par}}<RevThis macro has a first parameter that is delimited by~`\n{.\char32}',and a second parameter that is delimited by \cs{par}.The call\message{example on one page}\Ver>\section 2.5. Some titleThe text of the section...<Revwill give\disp\ver>#1<-2.5>\nl\ver>#2<-Some title>\n{\char32}\dispstopNote that there is a space at the end of the second argumentgenerated by the line end. If this space is unwanted one mightdefine \Ver>\def\section#1. #2 \par{...}<Revwith \n{\char32}\cs{par} delimiting the secondargument. This approach, however,precludes  the user's writing the \cs{par} explicitly:\Ver>\section 2.5 Some title\par<RevOne way out of this dilemma is to write\ver>#2\unskip> on all places in the definition textwhere the trailing space would be unwanted.Control sequences acting as delimiters need not be defined,as they are absorbed without expansion. Thus\Ver>\def\control#1\sequence{...}<Rev is a usefuldefinition, even if \cs{sequence} is undefined.The importance of category codes in delimited argumentsis shown by the following example:\Ver>\def\a#1 #2.{ ... }\catcode`\ =12\a b cd.<Revwhich gives\Ver>\a #1 #2.-> ...#1<- b c#2<-d<RevExplanation: the delimiter between parameters 1 and~2 is a spaceof category~10. In between \n{a} and \n{b} there is a spaceof category~12; the first space of  category~10is the space that is generated by the line end.For a `real-life' application of matching of category codes,see the explanation of \cs{newif} in Chapter~\ref[if],and the example on page~\pgref[ex:jobnumber].\spoint Empty argumentsIf the user specifies a \gr{balanced text} in braceswhen \TeX\ expects a macroargument, that text is used as the argument.Thus, specifying \ver-{}- will give an argument that isan empty list of tokens; this is called an `empty argument'.Empty arguments can also arise from the use of delimitedparameters. For example, after the definition\Ver>\def\mac#1\ro{ ... }<Revthe call\Ver>\mac\ro<Rev will give an empty argument. \commentHowever, onlyone empty argument can be created this way: if the macro had been defined as\Ver>\def\mac#1#2\ro{ ... }<Rev the same call\Ver>\mac\ro \othermacro \stillothermacro<Revwill probably cause a `\n{Runaway argument?}' error message.Explanation: the first parameter is undelimited, so the correspondingargument is `\cs{ro}'; after that \TeX\ starts looking for a listof tokens delimited by~\cs{ro}.\endcomment\spoint The macro parameter characterWhen \TeX's input processor scans a macro definition text, \term parameter character\parit inserts a parameter token for anyoccurrence of a macro parameter character followed by a digit.In effect, a parameter token in the replacement textstates `insert parameter number such and such here'.Two parameter characters in a row are replaced by a single one.The latter fact can be used for nested macro definitions.\label[nest:def]\howto Nested macro definitions\parThus \Ver>\def\a{\def\b#1{...}}<Rev gives an error messagebecause \cs{a} was defined without parameters, andyet there is a parameter token in its replacement text.The following\Ver>\def\a#1{\def\b#1{...}}<Rev defines a macro \cs{a} thatdefines a macro \cs{b}. However, \cs{b} still does nothave any parameters: the call\Ver>\a z<Rev defines a macro \cs{b} without parameters,that has to be followed by a~\n z.Note that thisdoes not attempt to define a macro \cs{bz}, because thecontrol sequence \cs{b} has already been formed in \TeX'sinput processor when that input line was read.Finally,\Ver>\def\a{\def\b##1{...}}<Rev defines a macro \cs{b} with one parameter.Let us examine the handling of the parameter characterin some detail.Consider \Ver>\def\a#1{ .. #1 .. \def\b##1{ ... }}<RevWhen this is read as input, the input processor\itemlist\item replaces the characters \ver>#1> by \gr{parameter token$_1$}, and\item replaces the characters \ver>##> by \ver>#>\>A macro call of \cs{a} will then let the input processor scan\Ver>\def\b#1{ ... }<Revin which the two characters \ver>#1> are\altreplaced by a parameter token.\spoint Brace delimitingOrdinarily, it is not possible to have left or rightbraces in the \gr{parameter text} of a definition.There is a special mechanism, however, that can makethe last parameter of a macro act as if it is delimitedby an opening brace. If the last parameter tokenis followed by a parameter character (\ver>#>),which in turn is followed by the opening brace of thereplacement text, \TeX\ makes the last parameterbe delimited by a beginning-of-group character.Furthermore, unlike other delimiting tokens inparameter texts, this opening brace is notremoved from the input stream.Consider an example.Suppose we want to have a macro\cs{every} that can fill token lists as follows:\Ver>\every par{abc} \every display{def}<RevThis macro can be defined as\Ver>\def\every#1#{\csname every#1\endcsname}<RevIn the first call above, the argument corresponding tothe parameter is \n{abc}, so the call expands to\Ver>\csname everypar\endcsname{abc}<Revwhich gives the desired result.\point[cs:name] Construction of control sequencesThe commands \cs{csname} and \cs{endcsname} can be used\csterm csname\par\csterm endcsname\parto construct a control sequence. For instance \Ver>\csname hskip\endcsname 5pt<Revis equivalent to \ver=\hskip5pt=.During this construction processall macros and other expandable control sequencesbetween \cs{csname} and \cs{endcsname}are expanded as usual, until only unexpandablecharacter tokens remain. A~variation of the above example,\Ver>\csname \ifhmode h\else v\fi skip\endcsname 5pt<Revperforms an \cs{hskip} or \cs{vskip} depending on the mode.The final result of the expansion should consist of only character tokens, buttheir category codes do not matter.An unexpandable control sequence gives an error here:\TeX\ will insert an \cs{endcsname} right before itas an attempt at error recovery.With \cs{csname} it is possible to constructcontrol sequences that cannot ordinarily be written,because the constituent character tokens may have another category\altthan~11, letter. This principle can be used to hide\howto Hide counters from the user\parinner control sequences of a macro package from the user.\example\Ver>\def\newcounter#1{\expandafter\newcount    \csname #1:counter\endcsname}\def\stepcounter#1{\expandafter\advance    \csname #1:counter\endcsname 1\relax}<RevIn the second definition the \cs{expandafter} is superfluous,but it does no harm, and it is conceptually clearer.\>The name of the actual counter created by \cs{newcounter}contains a colon, so that it takes some effort to write thiscontrol sequence. In effect, the counteris now hidden from the user, who can onlyaccess it through control sequences such as \cs{stepcounter}.By the way, the macro \cs{newcount} is defined \cs{outer} inthe plain format, so the above definition of \cs{newcounter}can only be written after \cs{newcount} has been redefined.If a control sequence formed with \ver>\csname...\endcsname>has not been definedbefore, its meaning is set to \cs{relax}.Thus if \ver=\xx= is an undefined control sequence, thecommand \Ver>\csname xx\endcsname<Rev will {\em not\/}give an error message, as it is equivalent to \ver=\relax=.Moreover, after this execution of the\ver-\csname...\endcsname- statement, the control sequence\ver=\xx= is itself equivalent to \cs{relax}, so itwill no longer give an `undefined control sequence' error(see also page~\pgref[relax:cs]).\point Token assignments by \cs{\let} and \cs{\futurelet}There are two \gr{let assignment}s in \TeX.Their syntax is\disp\cs{let}\gr{control sequence}\gr{equals}%     \gr{one optional space}\gr{token}\nl     \cs{futurelet}\gr{control sequence}\gr{token}\gr{token}     \>In the syntax of a \cs{futurelet} assignmentno optional equals sign appears.\spoint[let] \cs{let}The primitive command \cs{let} assigns the current meaning\csterm let\parof a~token to a control sequence or active character.For instance, in the plain format \cs{endgraf} is definedas \Ver>\let\endgraf=\par<RevThis enables macro writers to redefine \cs{par}, whilestill having the functionality of the primitive \cs{par}command available. For example,\Ver>\everypar={\bgroup\it\def\par{\endgraf\egroup}}<RevThe case where the \gr{token} to be assigned is not a controlsequence but a character token instead has been treated in Chapter~\ref[char].\spoint \cs{futurelet}As was explained above, the sequence with \cs{let}\disp\cs{let}\gr{control sequence}\gr{token$_1$}\gr{token$_2$}%       \gr{token$_3$}\gr{token$\cdots$}\dispstopassigns (the meaning of) \gr{token$_1$} to the control sequence, and the remaining input stream looks like\disp\gr{token$_2$}\gr{token$_3$}\gr{token$\cdots$}\dispstopThat is, the \gr{token$_1$} has disappeared from the stream.The command \cs{futurelet} works slightly differently:\csterm futurelet\pargiven the input stream\disp\cs{futurelet}\gr{control sequence}\gr{token$_1$}\gr{token$_2$}%       \gr{token$_3$}\gr{token$\cdots$}\dispstopit assigns (the meaning of) \gr{token$_2$} to the control sequence, and the remaining stream looks like\disp\gr{token$_1$}\gr{token$_2$}\gr{token$_3$}\gr{token$\cdots$}\dispstopThat is, neither \gr{token$_1$} nor \gr{token$_2$} hasbeen lifted from the stream.However, now \gr{token$_1$}`knows' what \gr{token$_2$} is, without having had to absorb itas a macro parameter. See an example below.If a character token has been \cs{futurelet} to a controlsequence, its category code is fixed.The subsequent \gr{token$_1$} cannot changeit anymore.\point Assorted remarks\spoint Active charactersCharacter tokens of category~13, `active characters',\alttcan be defined just like\term active character\parcontrol sequences.If the definition of the character appears inside a macro,the character has to be active at the time of the definitionof that macro.Consider for example the following definition(taken from Chapter~\ref[mouth]):\Ver>{\catcode`\^^M=13 % \gdef\obeylines{\catcode`\^^M=13 \def^^M{\par}}%}<RevThe unusual category of the \ver>^^M> characterhas to be set during the definition of \cs{obeylines},otherwise \TeX\ would think that the line endedafter \cs{def}.\spoint Macros versus primitivesThe distinction between primitive commands and user macros\term primitive commands\paris not nearly as important in \TeX\ as it is in otherprogramming languages.\itemlist\item The user can use primitive commands under different names:      \Ver>\let\StopThisParagraph=\par<Rev\item Names of primitive commands can be used for      user macros: \Ver>\def\par{\hfill$\bullet$\endgraf}<Rev\item Both user macros and a number of \TeX\ primitives      are subject to expansion, for instance all conditionals,      and commands such as \cs{number} and~\cs{jobname}.\itemliststop\spoint Tail recursionMacros in \TeX, like procedures in most modern programming\term recursion\parlanguages, are allowed to be recursive: that is, the definition of a macro can contain a call to this same macro,or to another macro that will call this macro.Recursive macros tend to clutter up \TeX's memoryif too many `incarnations' of such a macro are activeat the same time. However, \TeX\ is able to prevent thisin one frequently occurring case of recursion: tail recursion.In order to  appreciate what goes on here, some backgroundknowledge is needed. When \TeX\ starts executing a macroit absorbs the parameters, and places an item pointing tothe replacement text on the input stack,\term input stack\parso that the scanner will next be directed tothis replacement. Once it has been processed, the item on the input stack can be removed.However, if the definition textof a macro contains further macros, this process will berepeated for them: new items may be placed on the input stackdirecting the scanner to other macroseven before the first one has been completed.In general this `stack build-up' is a necessary evil, butit can be prevented if the nested macro call is the{\em last\/} token in the replacement text of the originalmacro. After the last token no further tokens need to beconsidered, so one might as well clear the top itemfrom the input stackbefore a new one is put there.This is what \TeX\ does.The \cs{loop} macro of plain \TeX\ provides a good illustration\label[loop:ex]\csterm loop\parof this principle. The definition is\Ver>\def\loop#1\repeat{\def\body{#1}\iterate}\def\iterate{\body \let\next=\iterate    \else \let\next=\relax\fi \next}<Revand this macro can be called for example as follows:\Ver>\loop \message{\number\MyCount}    \advance\MyCount by 1    \ifnum\MyCount<100 \repeat<RevThe macro \cs{iterate} can call itself and, when it does so,the recursive call is performed by the last token in the list.It would have been possible to define \cs{iterate}as \Ver>\def\iterate{\body \iterate\fi}<Revbut then \TeX\ would not have been able to resolve the recursionas the call \cs{iterate} is not the last token in the replacementtext of \cs{iterate}. Assigning \ver>\let\next=\iterate>is here a way to letthe recursive call be the last token in the list.Another way of resolving tail recursion is to use\cs{expandafter} (see page~\pgref[after:cond]): in\Ver>\def\iterate{\body \expandafter\iterate\fi}<Revit removes the \cs{fi} token.Tail recursion would also be resolved if the lasttokens in the list were arguments for therecursive macro.An aside: by defining \cs{iterate} as\Ver>\def\iterate{\let\next\relax     \body \let\next\iterate \fi \next}<Revit becomes possible to write\Ver>\loop ... \if... ... \else ... \repeat<Rev\point Macro techniques\spoint Unknown number of argumentsIn some applications,\howto  Macros with an undetermined numberof arguments\para macro is needed that can have anumber of arguments that is not specified in advance.Consider the problem of translating a position on a chess board(for full macros and fonts, see~\cite[chess] and~\cite[Tut]),given like\Ver>\White(Ke1,Qd1,Na1,e2,f4)<Rev to a sequence of typesetting instructions\Ver>\WhitePiece{K}{e1} \WhitePiece{Q}{d1} \WhitePiece{N}{a1} \WhitePiece{P}{e2} \WhitePiece{P}{f4}<RevNote that for pawns the `P' is omitted in the list of positions.The first problem is that the list of pieces is of variable length, so we append a terminator piece:\Ver>\def\White(#1){\xWhite#1,xxx,}\def\endpiece{xxx}<Revfor which we can test.Next, the macro \cs{xWhite} takes one position from the list,tests whether it is the terminator, and if not,subjects it to a test to see whether it is a pawn.\Ver>\def\xWhite#1,{\def\temp{#1}%    \ifx\temp\endpiece     \else \WhitePieceOrPawn#1XY%          \expandafter\xWhite     \fi}<RevAn \cs{expandafter} command is necessary to remove the\cs{fi} (see page~\pgref[after:cond]), so that \cs{xWhite} will get the next position as argumentinstead of \cs{fi}.Positions  are either two or three characters long.The call to \cs{White\-Piece\-OrPawn}, a four-parameter macro,appended a terminator string \n{XY}. In the case of a pawn, therefore, argument~3 is the character~\n Xand argument~4 is empty; for all other pieces argument~1is the piece, 2~and~3 are the position, and argument~4 is~\n X.\Ver>\def\WhitePieceOrPawn#1#2#3#4Y{    \if#3X \WhitePiece{P}{#1#2}%    \else  \WhitePiece{#1}{#2#3}\fi}<Rev\spoint Examining the argumentIt may be necessary in some cases to test whether a macro\howto Examine a macro argument for the presence of some element\par\howto Apply \cs{uppercase} when the argument has a \cs{footnote}\parargument contains some element. For a real-life example,consider the following (see also the \cs{DisplayEquation}\altexample on page~\pgref[left:display]).Suppose the title and author of an article are given as\Ver>\title{An angle trisector}\author{A.B. Cee\footnote*{Research supported by theVery Big Company of America}}<Rev with multiple authorsgiven as\Ver>\author{A.B. Cee\footnote*{Supported by NSF grant 1}        \and        X.Y. Zee\footnote{**}{Supported by NATO grant 2}}<RevSuppose further that the \cs{title} and \cs{author} macrosare defined as\Ver>\def\title#1{\def\TheTitle{#1}}  \def\author#1{\def\TheAuthor{#1}}<Revwhich will be used as\Ver>\def\ArticleHeading{ ... \TheTitle ... \TheAuthor ... }<RevFor some journals it is required tohave the authorship and the title of the article in all capitals.The implementation of this could be\Ver>\def\ArticleCapitalHeading   { ...    \uppercase\expandafter{\TheTitle}     ...    \uppercase\expandafter{\TheAuthor}     ...   }<RevNow the \cs{expandafter} commands will expand the title andauthor into the actual texts, and the \cs{uppercase} commandswill capitalize them. However, for the authors this is wrong,since the \cs{uppercase} command will also capitalize thefootnote texts.The problem is then to uppercase only the partsof the title in between the footnotes.As a first attempt, let us take the case of one author, andlet the basic call be\Ver>\expandafter\UCnoFootnote\TheAuthor<RevThis expands into\Ver>\UCnoFootnote A.B. Cee\footnote*{Supported ... }<RevThe macro\Ver>\def\UCnoFootnote#1\footnote#2#3{\uppercase{#1}\footnote{#2}{#3}}<Revwill analyse this correctly:\Ver>#1<-A.B. Cee#2<-*#3<-Supported ...<RevHowever, if there is no footnote, this macro is completely wrong.As a first refinement we add a footnote ourselves, just to makesure that one is present:\Ver>\expandafter\UCnoFootnote\TheAuthor\footnote 00<RevNow we have to test what kind of footnote we find:\Ver>\def\stopper{0}\def\UCnoFootnote#1\footnote#2#3{\uppercase{#1}\def\tester{#2}%    \ifx\stopper\tester    \else\footnote{#2}{#3}\fi}<RevWith \cs{ifx} we test the delimiter footnote sign against theactual sign encountered. Note that a solution with\Ver>\ifx0#2<Rev would be wrong if the footnote sign consistsof more than one token, for instance~\ver>{**}>.The macro so far is correct if there was no footnote,but if there was one it is wrong:the terminating tokens remain to be disposed of.They are taken care of in the following version:\Ver>\def\stopper{0}\def\UCnoFootnote#1\footnote#2#3{\uppercase{#1}\def\tester{#2}%    \ifx\stopper\tester    \else\footnote{#2}{#3}\expandafter\UCnoFootnote    \fi}<RevA repeated call to \cs{UCnoFootnote} removes the delimiter tokens(the \cs{expandafter} first removes the \cs{fi}),and as an added bonus, this macro is also correct for multipleauthors.\spoint Optional macro parameters with \cs{futurelet}One standard application of \cs{futurelet} is implementing\howto Macros with optional parameters\paroptional parameters of macros. The general course of actionis as follows:\Ver>\def\Com{\futurelet\testchar\MaybeOptArgCom}\def\MaybeOptArgCom{\ifx[\testchar \let\next\OptArgCom                  \else \let\next\NoOptArgCom \fi \next}\def\OptArgCom[#1]#2{ ... }\def\NoOptArgCom#1{ ... }<RevNote that \cs{ifx} is used even though it testsfor a character. The reason is of course that,if the optional argument is omitted, there might be anexpandable control sequence behind the~\cs{Com}.The macro \cs{Com} now has one optional and one regularargument; it can be called as \Ver>\Com{argument}<Rev or as\Ver>\Com[optional]{argument}<RevOften the call without the optional argument will insert somedefault value:\disp\ver>\def\NoOptArgCom#1{\OptArgCom[>%{\italic default\/}\ver>]{#1}}>\dispstopThis mechanism is widely used in formats such as \LaTeX\ and\LamsTeX; see also~\cite[svb:future].\spoint Two-step macrosOften what looks to the user like one macro is in realitya two-step process, where one macro will set up conditions,and a second macro will do the work.As an example, here isa macro \cs{PickToEol}\label[pick:eol]\howto Take an input line as macro argument\parwith an argument that is delimited by the line end.First we write a macro without arguments that changes the category code of the line end, and thencalls the second macro.\Ver>\def\PickToEol{\begingroup\catcode`\^^M=12 \xPickToEol}<RevThe second macro can then take as an argument everythingup to the end of the line:\Ver>\def\xPickToEol#1^^M{ ... #1 ... \endgroup}<RevThere is one problem with this definition: the \ver>^^M> charactershould have category~12. We arrive at the following:\Ver>\def\PickToEol{\begingroup\catcode`\^^M=12 \xPickToEol}{\catcode`\^^M=12 % \gdef\xPickToEol#1^^M{ ... #1 ... \endgroup}%}<Revwhere the category code of \ver>^^M> is changed for thesake of the definition of \cs{xPickToEol}. Note thatthe \ver>^^M> in \cs{PickToEol} occurs in a control symbol,so there the category code  is irrelevant. Therefore thatdefinition can be outside the group where the category code of \ver>^^M> is redefined.\spoint  A comment environmentAs an application of the above idea of two-step macros,\howto Comment environment\parand in order to illustrate tail recursion, here are macros for a `comment' environment.Often it is necessary to remove a part of \TeX\input temporarily. For this one would like towrite \Ver>\comment...\endcomment<RevThe simplest implementation of this, \Ver>\def\comment#1\endcomment{}<Rev has a number of weaknesses. For instance,it cannot cope with outer macros or input that does not have balanced braces. Its worstshortcoming, however, is that it reads the completecomment text as a macro argument. This limits the sizeof the comment to that of \TeX's input buffer.It would be a better idea to take on the out-commentedtext one line at a time. For this we want to writea recursive macro with a basic structure\Ver>\def\comment#1^^M{ ... \comment }<RevIn order to be able to write this definition at all,the category code of the line end must be changed; as above\alttwe will have\Ver>\def\comment{\begingroup \catcode`\^^M=12 \xcomment}{\catcode`\^^M=12 \endlinechar=-1 % \gdef\xcomment#1^^M{ ... \xcomment}}<RevChanging the \cs{endlinechar} is merely to prevent having to put comment characters at the endof every line of the definition.Of course, the process must stop at a certain time.To this purpose we investigate the line that wasscooped up as macro argument:\Ver>{\catcode`\^^M=12 \endlinechar=-1 % \gdef\xcomment#1^^M{\def\test{#1}    \ifx\test\endcomment \let\next=\endgroup    \else \let\next=\xcomment \fi    \next}}<Revand we have to define \cs{endcomment}:\Ver>\def\endcomment{\endcomment}<RevThis command will never be executed: it is merely for purposesof testing whether the end of the environment has been reached.We may want to comment out text that is not syntacticallycorrect. Therefore we switch to a verbatim mode\term verbatim mode\parwhen commenting. The following macro is given in plain \TeX:\Ver>\def\dospecials{\do\ \do\\\do\{\do\}\do\$\do\&%  \do\#\do\^\do\^^K\do\_\do\^^A\do\%\do\~}<RevWe use it to define \cs{comment} as follows:\Ver>\def\makeinnocent#1{\catcode`#1=12 }\def\comment{\begingroup    \let\do=\makeinnocent \dospecials    \endlinechar`\^^M \catcode`\^^M=12 \xcomment}<RevApart from the possibility mentioned above of commentingout text that is not syntactically correct, for instancebecause of unmatched braces, this solution can handleouter macros. The former implementation of \cs{xcomment}would cause a \TeX\ error if one occurred in the comment text.However, using verbatim mode poses the problem of concluding the environment.\alttThe final line of the comment is now not the control sequence\cs{endcomment}, but the characters constituting it. We haveto test for these then:\Ver>{\escapechar=-1 \xdef\endcomment{\string\\endcomment}}<Rev The sequence \ver>\string\\> gives a backslash.We could not have used\Ver>\edef\endcomment{\string\endcomment}<Rev becausethe letters of the word \n{endcomment} would then havecategory code~12, instead of the 11 that the ones on thelast line of the comment will have.\endinput