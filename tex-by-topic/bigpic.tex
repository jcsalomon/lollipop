%\tracingmacros=2 \tracingcommands=\tracingmacros\subject The Structure of \nl the \TeX\ Processor%\endinputThis book treats the various aspects of \TeX\ in chaptersthat are concerned with relatively small, well-delineated,topics. In this chapter, therefore, a global picture of the way \TeX\ operates will be given.Of necessity, many details will be omitted here, but all ofthese are treated in later chapters. On the other hand,the few examples given in this chapter will be repeatedin the appropriate places later on; they are included hereto make this chapter self-contained.\point Four \TeX\ processorsThe way \TeX\ processes its input can be viewed ashappening on four levels. One might  say thatthe \TeX\ processor is split into four separate units,each one accepting the output of the previous stage, anddelivering the input for the next stage. The input ofthe first stage is then the \n{.tex} input file; the outputof the last stage is a \n{.dvi} file.For many purposes it is most convenient, and most insightful,to consider these four levels of processing as happeningafter one another, each one accepting the {\em completed\/}output of the previous level. In reality this is not true:all levels are simultaneouslyactive, and there is interaction between them.The four levels are (corresponding roughlyto the `eyes', `mouth', `stomach', and `bowels' respectivelyin Knuth's original terminology) as follows.\enumerate\itemThe input processor. This is the piece of \TeX\ thataccepts input lines from the file system of whatever computer\TeX\ runs on, and turns them into tokens.Tokens are the internal objects of \TeX:there are character tokens that constitute the typesettext, and control sequence tokens that are commands to be processed by the next two levels.\item The expansion processor. Some but not all of the tokens generated in the first level\ldash macros, conditionals, and a numberof primitive \TeX\ commands \rdash  are subject to expansion.Expansion is the process that replaces some (sequences of)tokens by other (or no) tokens.\item The execution processor. Control sequences that are not expandable are executable,and this execution takes place on the third level of the\TeX\ processor.One part of the activity here concerns changes to\TeX's internal state: assignments (includingmacro definitions) are typical activities in this\awpcategory. The other major thing happening on this levelis the construction of horizontal, vertical, andmathematical lists.\item The visual processor. In the final level of processingthe visual part of \TeX\ processing is performed. Herehorizontal lists are broken into paragraphs, vertical lists are broken into pages,and  formulas are built out of math lists. Also the output to the \n{dvi} file takes place on this level.The algorithms working here are not accessible to the user,but they can be influenced by a number of parameters.\enumeratestop\point The input processorThe input processor of \TeX\ is that part of \TeX\ thattranslates whatever characters it gets from the input fileinto tokens. The output of this processor is a streamof tokens: a token list. Most tokens fall into one of two categories:character tokens and control sequence tokens. The remaining category is that of the parameter tokens;these will not be treated in this chapter.\spoint Character inputFor simple input text, characters are made intocharacter tokens. However, \TeX\ can ignore input characters:a row of spaces in the input is usually equivalent to just onespace. Also, \TeX\ itself can insert tokens that do not correspondto any character in the input, for instance the space tokenat the end of the line, or the \cs{par} token after an empty line.Not all character tokens signify characters to be typeset.\alttCharacters fall into sixteen categories \ldash each onespecifying a certain function that a character can have \rdash of which only two contain the characters that will betypeset. The other categories contain such characters as~\n{\char`\{}, \n{\char`\}}, \n\&, and~\n\#. A~character token can be consideredas a pair of numbers: the character code \ldash typically the \ascii\code \rdash  and the category code.It is possible to changethe category code that is associated with a particularcharacter code.When the escape character (by default~\cs{}$\,$) appears in the input,\TeX's behaviour in forming tokens is more complicated. Basically,\TeX\ builds a control sequence by taking a number of charactersfrom the input and lumping them together into a single token.The behaviour with which \TeX's input processor reacts to category codes can be describedas a machine that switches between three internal states:$N$,~new line; $M$,~middle of line; $S$,~skipping spaces.These states and the transitions between them are treatedin Chapter~\ref[mouth].\spoint Two-level input processing\TeX's input processor is in fact itself a two-level processor.Because of limitations of the terminal, the editor, or the operating\awpsystem, the user may not be able to input certain desired characters.Therefore, \TeX\ provides a mechanism to accesswith two superscript characters all of the available characterpositions. This may be considereda separate stage of \TeX\ processing, taking placeprior to the three-state machine mentioned above.For instance, the sequence \ver>^^+> is replaced by~\n{k} becausethe \ascii{} codes of \n k and \n + differ by~64. Since this replacement takes place before tokens are formed,writing \ver>\vs^^+ip 5cm> has the same effect as\ver>\vskip 5cm>. Examples more useful than this exist.Note that this first stage is a transformation fromcharacters to characters, without considering categorycodes. These come into play only in the second phaseof input processing where characters are convertedto character tokens by coupling the category codeto the character code.\point The expansion processor\TeX's  expansion processor accepts a stream of tokensand, if possible, expands the tokens in this stream one by oneuntil only unexpandable tokens remain.Macro expansion is the clearest example of this:if a control sequence is a macro name, it is replaced(together possibly with parameter tokens) by the definition text of the macro.Input for the expansion processor is provided mainlyby the input processor. The stream of tokens comingfrom the first stage of \TeX\ processing is subjectto the expansion process, and the result is a streamof unexpandable tokens which is fed to the execution processor.However, the expansion processor comes into play also when (among others) an \cs{edef} or \cs{write} is processed.The parameter token list of these commands isexpanded very much as if the lists had beenon the top level, instead of the argument to a command.\spoint The process of expansionExpanding a token consists of the following steps:\enumerate\item See whether the token is expandable. \item If the token is unexpandable, pass it to the token      list currently being built, and take on the next token. \item If the token is expandable, replace it by its expansion.      For macros without parameters, and a few primitive commands      such as \cs{jobname}, this is indeed a simple replacement.      Usually, however, \TeX\ needs to absorb some argument tokens from      the stream in order to be able to form the replacement      of the current token.      For instance, if the token was a macro with parameters,      sufficiently many tokens need to be absorbed to form      the arguments corresponding to  these parameters.\item Go on expanding, starting with the first token of the      expansion. \>%Deciding whether a token is expandable isa simple decision. Macros and active characters, conditionals, and a number of primitive \TeX\ commands\awp(see the list on page~\pgref[expand:lijst])are expandable, other tokens are not.Thus the expansion processor replaces macros by their expansion,it evaluates conditionals and eliminates any irrelevant parts of these, but tokens such as \cs{vskip} and character tokens,including characters such as dollars and braces, are passed untouched.\spoint Special cases: \cs{expandafter}, \cs{noexpand}, and \cs{the}As stated above,after a token has been expanded, \TeX\ will start expandingthe resulting tokens. At first sight the \cs{expandafter}command would seem to be an exception to this rule, becauseit expands only one step. What actually happens is thatthe sequence \disp\cs{expandafter}\gr{token$_1$}\gr{token$_2$}\dispstopis replaced by \disp\gr{token$_1$}\gr{\italic expansion of token$_2$}\dispstopand this replacement is in fact reexamined by the expansionprocessor.Real exceptions do exist, however. If the current token is the \cs{noexpand} command, the nexttoken is considered for the moment to be unexpandable:it is handled as if it were \cs{relax}, and it ispassed to the token list being built.For example,in the macro definition \Ver>\edef\a{\noexpand\b}<Revthe replacement text \ver>\noexpand\b> is expanded at definition time. The expansion of \cs{noexpand} is the next token, witha temporary meaning of \cs{relax}. Thus, when the expansionprocessor tackles the next token, the~\cs{b}, it will considerthat to be unexpandable, and just pass it to the token listbeing built, which is the replacement text of the macro.Another exception is that the tokensresulting from \cs{the}\gr{token variable}are not expanded further if this statement occursinside an \cs{edef} macro definition.\spoint Braces in the expansion processorAbove, it was said that braces are passed as unexpandablecharacter tokens. In general this is true. For instance,the \cs{romannumeral} command is handled by the expansionprocessor; when confronted with \Ver>\romannumeral1\number\count2 3{4 ...<Rev \TeX\ will expand until the brace is encountered:if \cs{count2} has the value of zero, the result will bethe roman numeral representation of~\n{103}.As another example, \Ver>\iftrue {\else }\fi<Revis handled by the expansion processor completely analogous to\disp\cs{iftrue} {\italic a}\cs{else} {\italic b}\cs{fi}\>\awpThe result is a character token, independent of its category.However, in the context of macro expansion the expansion  processor will recognize braces. First of all, a balanced pair of braces marks off a group of tokensto be passed as one argument.If a macro has an argument \Ver>\def\macro#1{ ... }<Revone can call it with a single token, as in\Ver>\macro 1 \macro \$<Revor with a group of tokens, surrounded by braces\Ver>\macro {abc} \macro {d{ef}g}<RevSecondly, when the arguments for a macro withparameters are read, no expressions with unbalanced bracesare accepted. In \Ver>\def\a#1\stop{ ... }<Rev the argument consists of alltokens up to the first occurrence of \cs{stop}that is not in braces: in\Ver>\a bc{d\stop}e\stop<Revthe argument of~\cs{a} is \ver>bc{d\stop}e>.Only balanced expressionsare accepted here.\point The execution processorThe execution processor builds lists: horizontal, vertical,and math lists. Corresponding to these lists, it worksin horizontal, vertical, or math mode. Of these three modes`internal' and `external' variants exist.In addition to building lists, this part of the \TeX\ processoralso performs mode-independent processing, such asassignments.Coming out of the expansion processor is a stream ofunexpandable tokens to be processed bythe execution processor. \relax From the point of view of the execution processor, thisstream contains two types of tokens:\itemlist\item Tokens signalling an assignment (this includes      macro definitions), and      other tokens signalling actions      that are independent of the mode, such      as \cs{show} and \cs{aftergroup}.\item Tokens that build lists:      characters, boxes, and glue. The way they are handled      depends on the current mode.\itemliststopSome objects can be used in any mode; for instance boxescan appear in horizontal, vertical, and math lists.The effect of such an object will of course still depend on the mode.Other objects are  specific for one mode.For instance, characters (to be more precise:character tokens of categories 11 and~12), are intimately connected to horizontal mode:if the execution processor is in vertical mode when it encounters a character, it willswitch to horizontal mode.Not all character tokens signal characters to be typeset:the execution processor can also encounter math shift\awpcharacters (by default~\n{\char`\$}) and beginning/end of groupcharacters (by default \n{\char`\{} and~\n{\char`\}}).Math shift characters let \TeX\ enter or exitmath mode, and braces let it enter or exit a~new level ofgrouping.One control sequence handled by the execution processor deserves special mention: \cs{relax}.This control sequence is not expandable, but the executionis to do nothing. Compare the effect of \cs{relax} in\Ver>\count0=1\relax 2<Rev with that of \cs{empty}defined by \Ver>\def\empty{}<Rev in \Ver>\count0=1\empty 2<Rev In the first case the expansionprocess that is forming the number stops at \cs{relax} andthe number {\tt 1} is assigned; in the second case \cs{empty} expands to nothing, so {\tt 12} is assigned.\point The visual processor\TeX's output processor encompasses those algorithms thatare outside direct user control: paragraph breaking,alignment, page breaking, math typesetting, and \n{dvi} filegeneration. Various parameters control the operationof these parts of \TeX.Some of these algorithms return their results in a form thatcan be handled by the execution processor. For instance,a paragraph that has been broken into lines is added tothe main vertical list as a sequence of horizontal boxeswith intermediate glue and penalties. Also, the page breakingalgorithm stores its result in \cs{box255}, so outputroutines can dissect it. On the other hand, a math formulacan not be broken into pieces, and, naturally, shipping a box to the \n{dvi} file is irreversible.\point Examples\spoint Skipped spacesSkipped spaces provide an illustration of the view that\TeX's levels of processing accept the completed inputof the previous level. Consider the commands\Ver>\def\a{\penalty200}\a 0<Rev This is {\italic not\/} equivalent to\Ver>\penalty200 0<Rev \awpwhich would place a penalty of \n{200}, andtypeset the digit~\n0. Instead it expands to\Ver>\penalty2000<Rev because the space after \cs{a} is skipped in theinput processor. Later stages of processing then receivethe sequence \Ver>\a0<Rev\spoint Internal quantities and their representations\TeX\ uses various sorts of internal quantities,such as integers and dimensions. These internalquantities have an external representation,which is a string of characters, such as \n{4711} or~\n{91.44cm}.Conversions between the internal value and the externalrepresentation take place on two different levels,depending on what direction the conversion goes.A~string of characters is converted to an internalvalue in assignments such as\Ver>\pageno=12 \baselineskip=13pt<Revor statements such as\Ver>\vskip 5.71pt<Revand all of these statements are handled by the executionprocessor.On the other hand, the conversion of the internalvalues into a representation as a string ofcharacters is handled by the expansion processor.For instance, \Ver>\number\pageno \romannumeral\year\the\baselineskip<Rev are all processed by expansion.As a final example, suppose \ver>\count2=45>, andconsider the statement\Ver>\count0=1\number\count2 3<RevThe expansion processor tackles \ver>\number\count2>to give the characters \n{45}, and the space afterthe \n 2 does not end the number being assigned:it only serves as a delimiterof the number of the \cs{count} register.In the next stage of processing, the execution processorwill then see the statement\Ver>\count0=1453<Rev and execute this.\endinput