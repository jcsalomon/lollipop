\subject[expand]  ExpansionExpansion in \TeX\ is rather different from procedure calls\term expansion\parin most programming languages. This chapter treats thecommands connected with expansion, and gives a number of(non-trivial) examples.\invent\item relax      Do nothing.\item expandafter        Take the next two tokens and place the expansion of the      second after the first.\item noexpand         Do not expand the next token.\item edef       Start a macro definition;       the replacement text is expanded at definition time. \item aftergroup        Save the next token for insertion after the current group.\item afterassignment         Save the next token for execution after the next assignment.\item the       Expand the value of various quantities in \TeX\ into a string      of character tokens.\inventstop\point Introduction\TeX's expansion processor accepts a stream of tokenscoming out of the input processor, and its result isagain a stream of tokens, which it feeds to the executionprocessor. For the input processor there are twokinds of tokens: expandable and unexpandable ones.The latter category is passed untouched, and it containslargely assignments and typesettable material;the former categoryis expanded, and the result of that expansion is examined anew.\point Ordinary expansionThe following list gives those constructsthat are expanded, unlessexpansion is inhibited:\itemlist\item macros\label[expand:lijst]\term expandable control sequences\par\item conditionals\item \cs{number}, \cs{romannumeral}\item \cs{string}, \cs{fontname}, \cs{jobname},       \cs{meaning}, \cs{the}\item \ver,\csname ... \endcsname,\item \cs{expandafter}, \cs{noexpand}\item \cs{topmark}, \cs{botmark}, \cs{firstmark},       \cs{splitfirstmark}, \cs{splitbotmark}\item \cs{input}, \cs{endinput}\itemliststopThis is the list of all instances whereexpansion is inhibited:\itemlist\label[noexp:list]\item when \TeX\ is reading a token to be defined by      \itemlist \item a \gr{let assignment}, that is,           by \cs{let} or \cs{futurelet},        \item a \gr{shorthand definition}, that is,           by \cs{chardef} or \cs{mathchardef}, or a           \gr{register def}, that is, \cs{countdef},           \cs{dimendef}, \cs{skipdef}, \cs{muskipdef},           or~\cs{toksdef},        \item a \gr{definition}, that is a macro definition           with \cs{def}, \cs{gdef}, \cs{edef}, or~\cs{xdef},        \item the \gr{simple assignment}s \cs{read} and \cs{font};      \itemliststop\item when a \gr{parameter text} or macro arguments      are being read; also when  the replacement text of a       control sequence      being defined by \cs{def}, \cs{gdef}, or \cs{read}      is being read;\item when the token list for a \gr{token variable} or      \cs{uppercase}, \cs{lowercase}, or \cs{write}      is being read; however, the token list for \cs{write}      will be  expanded later when it is shipped out;\item when tokens are being deleted during error recovery;\item when part of a conditional is being skipped;\item in two instances when \TeX\ has to know what follows      \itemlist\item after a left quote in a context where         that is used to denote an integer (thus in          \ver-\catcode`\a- the \cs{a} is not expanded), or        \item after a math shift character that begins math mode         to see whether another math shift character follows (in which case         a display opens);        \itemliststop\item when an alignment preamble is being scanned; however,      in this case a~token      preceded by \cs{span} and the tokens in a \cs{tabskip}       assignment are still expanded.\itemliststop\point Reversing expansion orderEvery once in a while you need to change the normal order ofexpansion of tokens. \TeX\ provides several mechanisms forthis. Some of the control sequences in this section arenot strictly concerned with expansion.\spoint One step expansion: \cs{expandafter}The most obvious tool for reversed expansion order is\csterm expandafter\par\cs{expandafter}. The sequence\disp\cs{expandafter}\gr{token$_1$}\gr{token$_2$}\dispstopexpands to \disp\gr{token$_1$}\gr{\italic the expansion of token$_2$}\dispstopNote the following.\itemlist \item If \gr{token$_2$} is a macro, it is replacedby its replacement text, not by its final expansion.Thus, if \Ver>\def\tokentwo{\ifsomecondition this \else that \fi}\def\tokenone#1{ ... }<Revthe call \Ver>\expandafter\tokenone\tokentwo<Revwill give \cs{ifsomecondition} as the parameterto \cs{tokenone}:\Ver>\tokenone #1-> ...#1<-\ifsomecondition<Rev\item If the \cs{tokentwo} is a macro with one or moreparameters, sufficiently many subsequent tokens will be absorbedto form the replacement text.\itemliststop\spoint[expand:edef] Total expansion: \cs{edef}Macros are usually defined by \cs{def}, but for the cases where\csterm edef\parone wants the replacement text to reflect current conditions(as opposed to conditions at the time of the call),there is an `expanding define', \cs{edef}, which expandseverything in the replacement text, before assigning it to thecontrol sequence. \example\Ver>\edef\modedef{This macro was defined in    `\ifvmode vertical\else \ifmmode math     \else horizontal\fi\fi' mode}<RevThe mode tests will be executed at definition time, so the replacement text will be a single string.As a more useful example, suppose that in a file that will be\cs{input} the category code of the~\n@ will be changed.One could then write\Ver>\edef\restorecat{\catcode`@=\the\catcode`@}<Revat the start, and \Ver>\restorecat<Rev at the end. See page~\pgref[store:cat]for a fully worked-out version of this.\>Contrary to the `one step expansion' of\cs{expandafter}, the expansion inside an \cs{edef} is complete:it goes onuntil only unexpandable character and control sequencetokens remain.There are two exceptions to this total expansion:\itemlist \item any control sequence preceded by \cs{noexpand}is not expanded, and,\item if \cs{sometokenlist} is a token list, the expression\Ver>\the\sometokenlist <Rev is expanded to the contentsof the list, but the contents are not expandedany further (see Chapter~\ref[token] for examples).\itemliststopOn certain occasions the \cs{edef} can conveniently beabused, in the sense that one is not interested in defininga control sequence, but only in the result of the  expansion.For example, with the definitions\alt\Ver>\def\othermacro{\ifnum1>0 {this}\else {that}\fi}\def\somemacro#1{ ... }<Rev the call\Ver>\expandafter\somemacro\othermacro <Revgives the parameter assignment\Ver>#1<-\ifnum<RevThis can be repaired by calling\Ver>\edef\next{\noexpand\somemacro\othermacro}\next<RevConditionals are completely expanded inside an \cs{edef},so the replacement text of \cs{next} will consist of the sequence\Ver>\somemacro{this}<Rev and a~subsequent call to \cs{next} executes this statement.\spoint \cs{afterassignment}The \cstoidx afterassignment\par\ commandtakes one token and sets it aside for insertionin the token streamafter the next assignment or macro definition.If the first assignment is of a~box to a box register,the token will be inserted right after the opening\altbrace of the box (see page~\pgref[every:box:assign]).Only one token can be saved this way; a subsequent token saved by \cs{afterassignment} will override the first.Let us consider an example of the use of \cs{afterassignment}.It is often desirable to have a macro that will\itemlist \item assign the argument to some variable, and then\item do a little calculation, based on the new valueof the variable.\itemliststopThe following example illustrates thestraightforward approach:\Ver>\def\setfontsize#1{\thefontsize=#1pt\relax    \baselineskip=1.2\thefontsize\relax}\setfontsize{10}<RevA more elegant solution is possible using \cs{afterassignment}:\Ver>\def\setbaselineskip   {\baselineskip=1.2\thefontsize\relax}\def\fontsize{\afterassignment\setbaselineskip    \thefontsize}\fontsize=10pt<RevNow the macro looks like an assignment: the equals signis even optional. In reality its expansionends with a variable to be assigned to. The control sequence\cs{setbaselineskip} is saved for execution afterthe assignment to \cs{thefontsize}.Examples of \cs{afterassignment} in plain \TeX\ arethe \cs{magnification} and \cs{hglue} macros.See \cite[Maus] for another creative application ofthis command.\spoint \cs{aftergroup}Several tokens can be saved for insertion after the current\csterm aftergroup\pargroup with an \disp\cs{aftergroup}\gr{token}\> command.The tokens are inserted after the group in the sequencethe \cs{aftergroup} commands were given in.The group can be delimited either by implicit or explicitbraces, or by \cs{begingroup} and \cs{endgroup}.\example\Ver>{\aftergroup\a \aftergroup\b}<Revis equivalent to \Ver>\a \b<Rev\>This command has many applications. One can be found\altin the \cs{textvcenter} macro on page~\pgref[text:vcenter];another one is providedby the footnote mechanism of plain \TeX.The footnote command of plain \TeX\ has the layout\label[footnote:ex]\disp\cs{footnote}\gr{footnote symbol}\lb\gr{footnote text}\rb\dispstop which looks like a macro with two arguments.However, it is undesirable to scoop up the footnote text,since this precludes forinstance category code changes in the footnote.What happens in the plain footnote macro is (globally) the following.\itemlist\item The \cs{footnote} command opensan insert, \Ver>\def\footnote#1{ ...#1... %treat the footnote sign    \insert\footins\bgroup<Rev\item In the insert box a group is opened,and an \cs{aftergroup} commandis given to close off the insert properly:\Ver>    \bgroup\aftergroup\@foot<RevThis command is meant to wind up after the closing brace ofthe text that the user typed to end the footnote text;the opening brace of the user's footnote text mustbe removed by \Ver>    \let\next=}%end of definition \footnote<Revwhich assigns the next token, the brace, to \cs{next}.\item The footnote text is set as ordinary textin this insert box.\item After the footnote the command \cs{@foot}defined by \Ver>\def\@foot{\strut\egroup}<Revwill be executed.\itemliststop\point Preventing expansionSometimes it is necessary to prevent expansion in a place\csterm noexpand\parwhere it normally occurs. For this purpose the controlsequences \cs{string} and \cs{noexpand} are available.The use of \cs{string} is rather limited, since it convertsa control sequence token into a string of characters, withthe value of \cs{escapechar} used for the character ofcategory code~0. It is eminently suitable for use in a \cs{write}, in order to output a control sequence name(see also Chapter~\ref[io]); for another application seethe explanation of \cs{newif} in Chapter~\ref[if].All characters resulting from \cs{string} have categorycode~12, `other', except for space characters; they receivecode~10. See also Chapter~\ref[char].\spoint \cs{noexpand}The \cs{noexpand} command is expandable, and its expansionis the following token. The meaning of that token ismade temporarily equal to \cs{relax}, so that it cannotbe expanded further.For \cs{noexpand} the most important application is probablyin \cs{edef} commands (but in write statements it can oftenreplace \cs{string}). Consider as an example\Ver> \edef\one{\def\noexpand\two{\the\prevdepth}}<RevWithout the \cs{noexpand}, \TeX\ would try to expand\cs{two}, thus giving an `undefined control sequence' error.A  (rather pointless)illustration of the fact that \cs{noexpand} makes the followingtoken effectively into a \cs{relax} is\Ver>\def\a{b}\noexpand\a<Rev This will not produce any output, because theeffect of the \cs{noexpand} is to make the control sequence\cs{a} temporarily equal to \cs{relax}.\spoint \cs{noexpand} and active charactersThe combination \cs{noexpand}\gr{token} is\term active characters, and \cs{noexpand}\parequivalent to \cs{relax}, even if the tokenis an active character. Thus,\Ver>\csname\noexpand~\endcsname<Revwill not be the same as~\ver>\char`\~>.Instead it will give an error message, becauseunexpandable commands \ldash such as \cs{relax} \rdash  are not allowed to appearin between \cs{csname} and \cs{endcsname}.The solution is to use \cs{string} instead; see page~\pgref[store:cat]for an example.In another context, however, the sequence\cs{noexpand}\gr{active character} is equivalentto the character, but in unexpandable form. This iswhen the conditionals \cs{if} and \cs{ifcat} are used(for an explanation of these, see Chapter~\ref[if]).Compare\Ver>\if\noexpand~\relax % is false<Revwhere the character code of the tilde is tested, with\Ver>\def\a{ ... } \if\noexpand\a\relax % is true<Revwhere two control sequences are tested.\point \cs{\relax}The control sequence \cs{relax} cannot be expanded, but\csterm relax\parwhen it is executed nothing happens.This statement sounds a bit paradoxical, so  consideran example. Let  counters \Ver>\newcount\MyCount\newcount\MyOtherCount \MyOtherCount=2<Rev be given.In the assignment \Ver>\MyCount=1\number\MyOtherCount3\relax4<Revthe command \cs{number} is expandable, and \cs{relax} is not.When \TeX\ constructs the number that is to be assignedit will expand all commands, either until a non-digit is found, or until an unexpandable command is encountered.Thus it reads the~\n1; it expands the sequence \ver>\number\MyOtherCount>,which gives~\n2; it reads the~\n3; it sees the \cs{relax}, andas this is unexpandable it halts. The number to be assignedis then \n{123}, and the whole call has been expanded into\Ver>\MyCount=123\relax4<RevSince the \cs{relax} token has no effect when it is executed,the result of this line is that \n{123} is assigned to\cs{MyCount}, and the digit 4 is printed.Another example of how \cs{relax} can be used to indicatethe end of a command\label[fil:l:l]\ is\Ver>\everypar{\hskip 0cm plus 1fil }\indent Later that day, ... <RevThis will be misunderstood: \TeX\ will see\Ver>\hskip 0cm plus 1fil L<Rev and \hbox{\n{fil L}} is a~valid,if bizarre,way of writing \n{fill} (see Chapter~\ref[gramm]).One remedy is to write\Ver>\everypar{\hskip 0cm plus 1fil\relax}<Rev\spoint[relax:cs] \cs{relax} and \cs{csname}If a \ver-\csname ... \endcsname- command forms the nameof a previously undefined control sequence,that control sequence is made equal to \cs{relax},and the whole statement is also equivalent to \cs{relax}(see also page~\pgref[cs:name]).However,  this assignment of \cs{relax} is\alttonly local:\Ver>{\xdef\test{\expandafter\noexpand\csname xx\endcsname}}\test<Rev gives an error message for anundefined control sequence~\cs{xx}.Consider as an example the \LaTeX\ environments,which are delimited by \Ver>\begin{...} ... \end{...}<RevThe begin and end commands are (in essence)defined as follows:\Ver>\def\begin#1{\begingroup\csname#1\endcsname}\def\end#1{\csname end#1\endcsname \endgroup}<RevThus, for the list environment the commands\cs{list} and \cs{endlist} are defined, but anycommand can be used as an environment name,even if no corresponding \cs{end...} has been defined.For instance, \Ver>\begin{it} ... \end{it}<Revis equivalent to \Ver>\begingroup\it ... \relax\endgroup<RevSee page~\pgref[begin:end:macros] for the rationalebehind using \cs{begingroup} and \cs{endgroup}instead of \cs{bgroup} and \cs{egroup}.\spoint Preventing expansion with \cs{relax}Because \cs{relax} cannot be expanded, a control sequence can be preventedfrom being expanded (for instance in an \cs{edef} or a \cs{write})by making it temporarily equal to \cs{relax}:\Ver>{\let\somemacro=\relax \write\outfile{\somemacro}}<Revwill write the string `\cs{somemacro}' to an output file.It would write the expansion of the macro \cs{somemacro} (or give an error messageif the macro is undefined) if the \cs{let} statementhad been omitted.\spoint[bump:relax] \TeX\ inserts a \cs{relax}\TeX\ itself inserts \cs{relax} on some occasions.For instance, \cs{relax} is inserted if \TeX\ encounters an\cs{or}, \cs{else}, or~\cs{fi} while still determiningthe extent of the test. \example\Ver>\ifvoid1\else ... \fi<Rev is changed into\Ver>\ifvoid1\relax \else ...\fi<Rev internally.\>Similarly, if one of the tests \cs{if}, \cs{ifcat}is given only one comparand, as in \Ver>\if1\else ...<Reva \cs{relax} token is inserted. Thus this testis equivalent to \Ver>\if1\relax\else ...<RevAnother place where \cs{relax} is used is the following.While a control sequence is being defined in a \gr{shorthanddefinition} \ldash that is, a \gr{registerdef} or \cs{chardef}or \cs{mathchardef} \rdash  its meaning is temporarily madeequal to \cs{relax}. This makes it possible to write\ver>\chardef\foo=123\foo>.\spoint The value of non-macros; \cs{the}Expansion is a precisely defined activity in \TeX.\csterm the\parThe full list of tokens that can be expandedwas given above. Other tokens than those in the above list may have an `expansion'in an informal sense. For instance one may wish to `expand'the \cs{parindent} into its value, say~\n{20pt}.Converting  the value of (among others) an\gr{integer parameter}, a \gr{glue parameter}, \gr{dimen parameter} or a \gr{token parameter}into a string of character tokens is done by the expansion processor.The command \cs{the}is expanded whenever expansion is not inhibited,and it takes the value of various sorts of parameters.Its result (in most cases)is a string of tokens of category~12, exceptthat spaces have category code~10.Here is the list of everything that can be prefixed with \cs{the}.\description\item \gr{parameter} or \gr{register}If the parameter or register is of type integer, glue, dimenor muglue,its value is given as a string of character tokens;if it is of type token list (for instance\cs{everypar} or \cs{toks5}), the result is a string of tokens.Box registers are excluded here.\item \gr{codename}\gr{8-bit number}See page~\pgref[codename].\item \gr{special register}The integer registers \cs{prevgraf}, \cs{deadcycles}, \cs{insertpenalties}\cs{inputlineno}, \cs{badness}, \cs{parshape}, \cs{spacefactor}(only in horizontal mode), or \cs{prevdepth} (only in vertical mode).The dimension registers \cs{pagetotal}, \cs{pagegoal}, \cs{pagestretch},\cs{pagefilstretch}, \cs{pagefillstretch}, \cs{pagefilllstretch},\cs{pageshrink}, or \cs{pagedepth}.\item Font properties:\cs{fontdimen}\gr{parameter number}\gr{font}, \cs{skew\-char}\gr{font},\cs{hy\-phen\-char}\gr{font}.\item Last quantities:\cs{lastpenalty}, \cs{lastkern}, \cs{lastskip}.\item \gr{defined character}Any control sequence defined by \cs{chardef} or \cs{mathchardef};the result is the decimal value.\>In some cases \cs{the} can give a control sequence token or list of such tokens.\description\item \gr{font}The result is the control sequence that stands for thefont.\item \gr{token variable}Token list registers and \gr{token parameter}s can be prefixedwith \cs{the}; the result is their contents.\>Let us consider an example of the use of \cs{the}.If in a file that is to be \cs{input} thecategory code of a character, say the at~sign, is changed,one could write\Ver>\edef\restorecat{\catcode`@=\the\catcode`@}<Revand call \cs{restorecat} at the end of the file.If the category code was~11, \cs{restorecat}is defined equivalent to \Ver>\catcode`@=11<RevSee page~\pgref[store:cat] for more elaborate macrosfor saving and restoring catcodes.\point Examples\spoint Expanding afterThe most obvious use of \cs{expandafter} is to reach overa control sequence:\Ver>\def\stepcounter    #1{\expandafter\advance\csname              #1:counter\endcsname 1\relax}\stepcounter{foo}<RevHere the \cs{expandafter} lets the \cs{csname} command formthe control sequence \cs{foo:counter}; after \cs{expandafter}is finished the statement has reduced to\Ver>\advance\foo:counter 1\relax<RevIt is possible to reach over tokens other than control sequences: in\Ver>\uppercase\expandafter{\romannumeral \year}<Revit expands  \cs{romannumeral} on the other side of the openingbrace.You can expand after two control sequences:\Ver>\def\globalstepcounter    #1{\expandafter\global\expandafter\advance             \csname #1:counter\endcsname 1\relax}<RevIf you think of \cs{expandafter} as reversing the evaluationorder of {\sl two\/} control sequences, you can reverse{\sl three\/} by\Ver>\expandafter\expandafter\expandafter\a\expandafter\b\c <Revwhich reaches across the three control sequences\Ver>            \expandafter            \a            \b <Rev to expand \cs{c} first.There is even an unexpected use for \cs{expandafter} inconditionals;with \Ver>\def\bold#1{{\bf #1}}<Revthe sequence \Ver>\ifnum1>0 \bold \fi {word}<Revwill not give a boldface `word', but\Ver>\ifnum1>0 \expandafter\bold \fi {word}<Rev will.The \cs{expandafter} lets \TeX\ see the \cs{fi} and remove itbefore it tackles the macro \cs{bold}(see also page~\pgref[after:cond]).\spoint Defining inside an \cs{edef}There is one \TeX\ command that is executed instead ofexpanded that is worth pointing out explicitly:the primitive command \cs{def} (and all other \gr{def} commands)is not expanded.Thus the call\Ver>\edef\next{\def\thing{text}}<Rev will give an `undefinedcontrol sequence' for \cs{thing}, even though after\cs{def} expansion is ordinarily inhibited (see page~\pgref[noexp:list]).After \Ver>\edef\next{\def\noexpand\thing{text}}<Revthe `meaning' of \cs{next} will be \Ver>macro: \def \thing {text}<RevThe definition \Ver>\edef\next{\def\noexpand\thing{text}\thing}<Revwill again give an `undefined control sequence' for \cs{thing}(this time on its second occurrence),as it will only be defined when \cs{next} is called,not when \cs{next} is defined.\spoint[expand:write] Expansion and \cs{write}The argument token list of \cs{write} is treated in much\csterm write\parthe same way as the replacement text of an \cs{edef};that is, expandable control sequences and active charactersare completely expanded. Unexpandable control sequencesare treated by \cs{write} as if they are prefixedby \cs{string}.Because of the expansion performed by \cs{write},some care has to be taken when outputting controlsequences with \cs{write}.Even more complications arise from the fact that the expansion of the argument of \cs{write} is only performedwhen it is shipped out. Here follows a worked-outexample.Suppose \cs{somecs} is a macro, and youwant to write the string \disp\ver-\def\othercs-\lb {\italic the expansion of \cs{somecs}}\rb\dispstopto a file.The first attempt is\Ver>\write\myfile{\def\othercs{\somecs}}<RevThis gives an error `undefined control sequence' for \cs{othercs},\alttbecause the \cs{write} will try to expand that token. Note that the \cs{somecs} is also  expanded, so that part is right.The next attempt is\Ver>\write\myfile{\def\noexpand\othercs{\somecs}}<RevThis is almost right, but not quite. Thestatement written is\disp\ver>\def\othercs>\lb{\italic expansion of \cs{somecs}}\rb\dispstopwhich looks right.However, writes \ldash and the expansion of their argument \rdash are not executedon the spot, but saved until the part of the page on whichthey occur is shipped out (see Chapter~\ref[io]).So, in the meantime, the value of \cs{somecs} may havechanged. In other words, the value written may not be thevalue at the time the \cs{write} command was given.Somehow, therefore, the current expansion must beinserted in the write command.The following is an attempt at repair:\Ver>\edef\act{\write\myfile{\def\noexpand\othercs{\somecs}}}\act<Rev Now the  write command will be\disp\ver>\write\myfile{\def\othercs{>\italic value of\/     \ver>\somecs}}>\dispstopThe \cs{noexpand} prevented the \cs{edef} from expandingthe \cs{othercs}, but after the definition it has disappeared,so that execution of the write will again give an undefined controlsequence. The final solution is\Ver>\edef\act{\write\myfile          {\def \noexpand\noexpand \noexpand\othercs{\somecs}}}\act<Rev In this case the write command caused by the expansion of \cs{act}will be\disp\ver>\write\myfile{\def\noexpand\othercs>\lb     {\italic current value of \cs{somecs}}\rb\dispstopand the string actually written is\disp\ver>\def\othercs>\lb     {\italic current value of \cs{somecs}}\rb\dispstopThis mechanism is the basis for cross-referencingmacros in several macro packages.\spoint Controlled expansion inside an \cs{edef}Sometimes you may need an \cs{edef} to evaluate current\howto Control expansion inside an \cs\edef\parconditions, but you want to expand something in the replacementtext only to a certain level. Suppose that\Ver>\def\a{\b} \def\b{c} \def\d{\e} \def\e{f}<Revis given, and you want to define \cs{g} as \cs{a} expandedone step, followed by \cs{d} fully expanded. The followingworks:\Ver>\edef\g{\expandafter\noexpand\a \d}<RevExplanation: the \cs{expandafter} reaches over the \cs{noexpand}to expand \cs{a} one step, after which the sequence \ver-\noexpand\b- is left.This trick comes in handy when you need toconstruct a control sequence with \cs{csname} inside an \cs{edef}. The following sequence inside an \cs{edef}\Ver>\expandafter\noexpand\csname name\endcsname<Revwill expand exactly to \cs{name}, but not further.As an example, suppose\Ver>\def\condition{true}<Rev has been given, then\Ver>\edef\setmycondition{\expandafter\noexpand           \csname mytest\condition\endcsname}<Revwill let \cs{setmycondition} expand to \cs{mytesttrue}.\spoint Multiple prevention of expansionAs   was pointed out above, prefixing  a command with\cs{noexpand} prevents its expansion in commandssuch as \cs{edef} and~\cs{write}. However, if a sequence of tokenspasses through more than one expanding commandstronger measures are needed.The following trick can be used\csterm protect\par:in order to protect a command against expansionit can be prefixed with \cs{protect}.During the stages of processing where expansion isnot desired the definition of \cs{protect} is\Ver>\def\protect{\noexpand\protect\noexpand}<RevLater on, when the command is actually needed,\cs{protect} is defined as \Ver>\def\protect{}<RevWhy does this work? The expansion of\Ver>\protect\somecs<Rev is at first\Ver>\noexpand\protect\noexpand\somecs<RevInside an \cs{edef} this sequence is expanded further,and the subsequent expansion is\Ver>\protect\somecs<RevThat is, the expansion is equal to the original sequence.\spoint More examples with \cs{relax}Above, a first example was given in which \cs{relax} servedto prevent \TeX\ from scanning too far.Here are some more examples, using \cs{relax} to boundnumbers.After\Ver>\countdef\pageno=0 \pageno=1\def\Par{\par\penalty200}<Revthe sequence \Ver>\Par\number\pageno<Rev is misunderstood as\Ver>\par\penalty2001<RevIn this case it is sufficient to define\Ver>\def\Par{\par\penalty200 }<Revas an \gr{optional space} is allowed to follow a number.Sometimes, however, such a simple escape is not possible.Consider the definition\Ver>\def\ifequal#1#2{\ifnum#1=#2 1\else 0\fi}<RevThe question is whether the space after \ver-#2-is necessary, superfluous, or simply wrong.Calls such as \ver-\ifequal{27}{28}- that compare twonumbers (denotations) will correctly give \n1 or~\n0,and the space is necessary to prevent misinterpretation.However, \ver-\ifequal\somecounter\othercounter- willgive \n{\char 32 1} if the counters are equal; in thiscase the space could have been dispensed with.The solution that works in both cases is\Ver>\def\ifequal#1#2{\ifnum#1=#2\relax 1\else 0\fi}<RevNote that \cs{relax} is not expanded, so\Ver>\edef\foo{1\ifequal\counta\countb}<Revwill define \cs{foo} as either \ver-1\relax1- or~\n{10}.\spoint[store:cat] Example: category code saving and restoringIn many applications it is necessary to change\howto Save and restore category codes\parthe category code of a certain character during theexecution of some piece of code. If the writer ofthat code is also the writer of the surrounding code,s/he can simply change the category code back and forth.However, if the surrounding code is by another author,the value of the category code will have to be storedand restored.Thus one would like to write\Ver>\storecat@... some code ...\restorecat@<Revor maybe \Ver>\storecat\%<Rev for characters thatare possibly a comment character (or ignored or invalid).\altThe basic idea is to define\Ver>\def\storecat#1{%    \expandafter\edef\csname restorecat#1\endcsname        {\catcode`#1=\the\catcode`#1}}<Revso that, for instance, \ver>\storecat$> will definethe single control sequence `\ver>\restorecat$>'(one control sequence) as \Ver>\catcode`$=3<RevThe macro \cs{restorecat} can then be implemented as\Ver>\def\restorecat#1{%    \csname restorecat#1\endcsname}<RevUnfortunately, things are not so simple.The problems occur with active characters, because theseare expanded inside the \ver>\csname ... \endcsname> pairs.One might be tempted to write \ver>\noexpand#1> everywhere,but this is wrong. As was explained above, this is essentiallyequal to \cs{relax}, which is unexpandable, and will thereforelead to an error message when it appears between\cs{csname} and \cs{endcsname}. The proper solution is thento use \ver>\string#1>. For the case where the argumentwas given as a control symbol (for example~\ver>\%>),the escape character has to be switched off for a while. Here are the complete macros. The \cs{storecat} macrogives its argument a default category code of~12.\Ver>\newcount\tempcounta % just a temporary\def\csarg#1#2{\expandafter#1\csname#2\endcsname}\def\storecat#1%   {\tempcounta\escapechar \escapechar=-1    \csarg\edef{restorecat\string#1}%          {\catcode`\string#1=                \the\catcode\expandafter`\string#1}%    \catcode\expandafter`\string#1=12\relax    \escapechar\tempcounta}\def\restorecat#1%   {\tempcounta\escapechar \escapechar=-1    \csname restorecat\string#1\endcsname    \escapechar\tempcounta}<Rev\spoint Combining \cs{aftergroup} and boxes%\tracingmacros=2 \tracingcommands=2At times, one wants to construct a box and immediatelyafter it has been constructed todo something with it. The \cs{aftergroup} commandcan be used to put both the commands creating the box,and the ones handling it, in one macro.As an example, here is a macro \cs{textvcenter}\label[text:vcenter]\which defines a variant of the \cs{vcenter} box\howto \cs\vcenter\ outside math mode\par(see page~\pgref[vcenter]\label[tvcenter])that can be used outside math mode.\Ver>\def\textvcenter   {\hbox \bgroup$\everyvbox{\everyvbox{}%    \aftergroup$\aftergroup\egroup}\vcenter}<RevThe idea is that the macro inserts \ver>\hbox {$>,and that the matching \ver>$}> gets insertedby the \cs{aftergroup} commands. In order to get the \cs{aftergroup} commands inside the box, an\cs{everyvbox} command is  used.This macro can even be used with a \gr{box specification}(see page~\pgref[box:spec]), for example\Ver>\textvcenter spread 8pt{\hbox{a}\vfil\hbox{b}}<Revand because it  is really just an \cs{hbox}, it can alsobe used in a \cs{setbox} assignment.\spoint More expansionThere is a particular charm to macros that workpurely by expansion. See the articles by\cite[E2], \cite[J], and~\cite[Maus2].\endinput